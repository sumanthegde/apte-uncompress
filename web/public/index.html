<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Apte Dictionary Expanded</title>
    <link rel="stylesheet" href="css/styles.css">
    <script src="js/sanscript.js"></script>
    <script src="js/state.js"></script>
    <script src="js/slputils.js"></script>
    <script src="js/textprocessing.js"></script>
    <script src="js/termprocessing.js"></script>
    <script src="js/utils.js"></script>

</head>

<body>
    <div class="container">
        <!-- Header with search functionality - fixed at top -->
        <div id="header"
            style="position: fixed; top: 0; left: 0; right: 0; background-color: #f5f5f5; box-shadow: 0 2px 5px rgba(0,0,0,0.1); padding: 15px; z-index: 100;">
            <div style="display: flex; justify-content: space-between; align-items: center;">
                <!-- Simple two-line title on the left, center-aligned text -->
                <div id="site-title" style="margin-left: 20px; color: #74591f; text-align: center; width: 180px;">
                    <div style="font-weight: bold; font-size: 1.2em;">Apte Dictionary</div>
                    <div style="font-size: 0.8em; color: #666; white-space: nowrap;">with compounds expanded</div>
                </div>

                <!-- Search in the middle - centered group -->
                <div style="flex-grow: 1; display: flex; justify-content: center; align-items: center;">
                    <div style="position: relative; display: flex; align-items: flex-start;">
                        <div style="display:flex; flex-direction:column; align-items:start;">
                            <input type="text" id="user-input"
                                style="padding: 8px; width: 300px; margin-right: 10px; font-size: 1.2em; font-family: 'Noto Sans Devanagari', 'Sanskrit 2003', sans-serif;">
                            <div class="search-instruction" style="text-align: center; margin: 5px 0; font-size: 12px; color: #777;">
                                Tip: prefix a slash ( / ) to search within meaning texts
                            </div>
                        </div>
                        <div id="suggestions-container" class="suggestions-container"></div>
                        <button id="search-button"
                            style="background-color: #4CAF50; color: white; border: none; padding: 0 16px; height: 40px; cursor: pointer; border-radius: 4px; display: flex; align-items: center;">Search</button>
                    </div>
                </div>

                <!-- Email feedback link on the right -->
                <div style="margin-right: 20px;">
                    <a href="mailto:sumant.sanskrit@gmail.com?subject=Apte Dictionary Feedback" title="Send Feedback"
                        style="transition: opacity 0.2s;">
                        <svg width="24" height="24" viewBox="0 0 24 24" fill="#666" style="transition: fill 0.2s;">
                            <path
                                d="M20 4H4c-1.1 0-1.99.9-1.99 2L2 18c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V6c0-1.1-.9-2-2-2zm0 4l-8 5-8-5V6l8 5 8-5v2z">
                            </path>
                        </svg>
                    </a>
                </div>
            </div>
        </div>

        <!-- Spacer to push content below the fixed header -->
        <div id="header-spacer" style="height: 70px;"></div>

        <!-- Main content area -->
        <div id="content-area">
            <div id="text-query-results-container" style="display: none;">
            </div>

            <div id="bookview-container">
                <!-- Loading indicator -->
                <div id="loading" class="loading">
                    <div
                        style="display: inline-block; animation: spin 1s linear infinite; font-size: 16px; margin-right: 5px;">
                        ⟳</div>
                    <span>Loading...</span>
                </div>

                <!-- Error message -->
                <div id="error" class="error" style="display: none;"></div>

                <!-- Keyboard navigation hint for top of page -->
                <div id="keyboard-hint-top"
                    style="text-align: center; margin: 5px 0; font-size: 12px; color: #777; display: none;">
                    Hit the ↑ key to see previous entries
                </div>

                <!-- Terms container -->
                <div id="terms-container"></div>

                <!-- Scroll loading indicators -->
                <div id="load-more-top-button" style="text-align: center; margin: 10px 0; display: none;">
                    <button id="load-more-top"
                        style="background-color: #4CAF50; color: white; border: none; padding: 8px 16px; cursor: pointer; border-radius: 4px;">Load
                        More Above ▲</button>
                </div>

                <div id="loading-top" class="scroll-loading-indicator">
                    <div
                        style="display: inline-block; animation: spin 1s linear infinite; font-size: 14px; margin-right: 3px;">
                        ⟳</div>
                    <span>Loading...</span>
                </div>
                <div id="loading-bottom" class="scroll-loading-indicator">
                    <div
                        style="display: inline-block; animation: spin 1s linear infinite; font-size: 14px; margin-right: 3px;">
                        ⟳</div>
                    <span>Loading...</span>
                </div>

                <!-- Keyboard navigation hint for bottom of page -->
                <div id="keyboard-hint-bottom"
                    style="text-align: center; margin: 5px 0; font-size: 12px; color: #777; display: none;">
                    Hit the ↓ key to see more entries
                </div>
            </div>
        </div>
    </div>

    <script>

        // Function to load pagemarks data
        async function loadPagemarks() {
            const response = await fetch('/pagemarks-data.json');
            if (!response.ok) {
                throw new Error(`HTTP error! Status: ${response.status}`);
            }
            const data = await response.json();
            pagemarks = data.pagemarks;
            sortedPagemarkKeys = data.sortedKeys;
            return pagemarks;
        }

        // Function to load a single term
        async function loadSingleTerm(termId) {
            try {
                // Check if term is already loaded
                if (loadedTermIds.has(termId)) {
                    return loadedTerms[termId];
                }
                const response = await fetch(`${TERM_URL_BASE}/${termId}.json`);
                if (!response.ok) {
                    // If we get a 404, it might be a gap in the term numbering
                    if (response.status === 404) {
                        return [];
                    } else {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                }
                const termData = await response.json();

                // Store in loaded terms
                loadedTerms[termId] = [termData];
                loadedTermIds.add(termId);

                return [termData];
            } catch (error) {
                console.error(`${error.message}`);
                return [];
            }
        }

        // Function to load a term and its context (n-10 to n+10)
        async function loadAndRenderTermsFrom(termId) {
            return new Promise(async (resolve, reject) => {
                try {
                    isLoading = true;

                    // First load pagemarks if not already loaded
                    if (Object.keys(pagemarks).length === 0) {
                        await loadPagemarks();
                    }

                    // Set current term ID and requested term ID
                    currentTermId = termId;
                    requestedTermId = termId; // This is the term the user specifically requested

                    // Always force a re-render, even if the term is already loaded
                    // This ensures highlighting is updated for the current searchedWord

                    // Calculate the range of terms to load
                    const startTermId = termId; // Start from the current term (no terms before)
                    const endTermId = termId + WINDOW_AFTER; // Load 15 terms after

                    // Show loading message
                    document.getElementById('error').style.display = 'none';
                    document.getElementById('loading').style.display = 'block';
                    document.getElementById('loading').innerHTML = `
                        <div style="display: inline-block; animation: spin 1s linear infinite; font-size: 24px; margin-right: 10px;">⟳</div>
                        <span>Loading dictionary...</span>
                    `;

                    // Set a safety timeout to ensure the loading message doesn't get stuck
                    const loadingTimeout = setTimeout(() => {

                        document.getElementById('loading').style.display = 'none';
                    }, 10000); // 10 second timeout

                    // Load all terms in the range
                    const loadPromises = [];
                    for (let id = startTermId; id <= endTermId; id++) {
                        loadPromises.push(loadSingleTerm(id));
                    }

                    await Promise.all(loadPromises);

                    // Clear the safety timeout
                    clearTimeout(loadingTimeout);


                    // Hide loading message
                    document.getElementById('loading').style.display = 'none';

                    // Render the terms
                    renderTermsInRange(startTermId, endTermId);


                    // Show keyboard navigation hints
                    document.getElementById('keyboard-hint-top').style.display = 'block';
                    document.getElementById('keyboard-hint-bottom').style.display = 'block';


                    isLoading = false;
                    resolve();
                } catch (error) {


                    // Make sure to clear any loading timeouts
                    if (typeof loadingTimeout !== 'undefined') {
                        clearTimeout(loadingTimeout);
                    }

                    // Hide loading message and show error
                    document.getElementById('loading').style.display = 'none';
                    document.getElementById('error').style.display = 'block';
                    document.getElementById('error').textContent = `Error loading terms: ${error.message}`;
                    document.getElementById('keyboard-hint-top').style.display = 'none';
                    isLoading = false;
                    reject(error);
                }
            });
        }

        // Function to render terms in a specific range
        function renderTermsInRange(startTermId, endTermId) {
            const termsContainer = document.getElementById('terms-container');
            termsContainer.innerHTML = '';

            console.log(`Debug: searchedWord ${searchedWord}`);
            for (let id = startTermId; id <= endTermId; id++) {
                if (loadedTermIds.has(id)) {
                    const termData = loadedTerms[id];

                    // Create a container for this term
                    const termContainer = document.createElement('div');
                    termContainer.className = 'term-container';
                    termContainer.dataset.termId = id;

                    // Add highlighting class if this is the requested term
                    if (id === requestedTermId) {
                        termContainer.classList.add('highlighted');
                    }

                    // Check if it's a placeholder
                    if (termData[0].__placeholder) {
                        termContainer.innerHTML = `<div class="term-row"><em>Term ${id} not available</em></div>`;
                    } else {
                        // Always re-render the term to ensure highlighting is updated
                        // This is important when looking up different words within the same term
                        termContainer.innerHTML = termData.map(term => processTerm(term)).join('');
                    }

                    // Add term ID as a clickable link
                    termContainer.appendChild(createPdfLink(termContainer, id));

                    termsContainer.appendChild(termContainer);
                }
            }

        }

        // Function to navigate to a specific term
        function resetAndLoadAndRenderTermsFrom(termId, word, deleteTextQueryResults=false, textQueryFlow=false) {
            console.log(`termId ${termId} word ${word} deleteTextQueryResults ${deleteTextQueryResults}`);
            return new Promise((resolve, reject) => {
                if (isLoading) return resolve();

                // If a word is provided, set it as the searchedWord for highlighting
                if (word) {
                    searchedWord = word.trim();
                    textSearchMode = textQueryFlow;
                }

                // Parse termId as integer
                termId = parseInt(termId, 10);
                if (isNaN(termId) || termId <= 0) {
                    alert('Please enter a valid Term ID');
                    return resolve();
                }

                // Force scroll to top to reset view
                window.scrollTo(0, 0);

                // Clean up sliding window and related bookkeeping variables
                // Clear the terms container
                const termsContainer = document.getElementById('terms-container');
                termsContainer.innerHTML = '';

                // Reset the loadedTermIds set
                loadedTermIds.clear();

                // Reset the loadedTerms object
                loadedTerms = {};

                // Clear any previous errors
                document.getElementById('error').style.display = 'none';
                document.getElementById('loading').style.display = 'block';
                document.getElementById('loading').innerHTML = `
                    <div style="display: inline-block; animation: spin 1s linear infinite; font-size: 16px; margin-right: 5px;">⟳</div>
                    <span>Loading...</span>
                `;

                // Clear text-results if needed
                if(deleteTextQueryResults){
                    const resultsContainer = document.getElementById('text-query-results-container');
                    resultsContainer.style.display = 'none';
                    resultsContainer.innerHTML = '';
                }
                // Set a safety timeout to ensure the loading message doesn't get stuck
                const navTimeout = setTimeout(
                    () => {
                        document.getElementById('loading').style.display = 'none';
                    }, 10000
                ); // 10 second timeout

                // Load the term and its context
                loadAndRenderTermsFrom(termId).then(() => {
                    // Clear the navigation timeout when loading completes
                    clearTimeout(navTimeout);
                    resolve();
                }).catch(error => {
                    // Clear the navigation timeout when loading fails
                    clearTimeout(navTimeout);
                    reject(error);
                });
            });
        }

        // Lookup a word in table_new.txt. This is convergence point for search-button-click & suggestion-click.
        async function lookupDevanagariWord(word, isAlternativeAttempt = false) {
            return new Promise(async (resolve, reject) => {
                if (isLoading) return resolve();

                if (!word) {
                    alert('Please enter a word');
                    return resolve();
                }

                // Check if the input is likely in SLP1 format
                const originalWord = word;
                let isSLP1Input = false;
                if (isLikelySLP1(word)) {
                    try {
                        // Convert SLP1 to Devanagari
                        word = Sanscript.t(word, 'slp1', 'devanagari');
                        console.log(`Converted SLP1 input "${originalWord}" to Devanagari: "${word}"`);
                        isSLP1Input = true;
                    } catch (e) {
                        console.error(`Error converting SLP1 to Devanagari: ${e.message}`);
                        // Continue with original input if conversion fails
                        word = originalWord;
                    }
                }

                // Force scroll to top to reset view
                window.scrollTo(0, 0);

                // Reset window state variables
                currentTermId = null;
                requestedTermId = null;

                isLoadingTop = false;
                isLoadingBottom = false;

                // Show loading message
                document.getElementById('error').style.display = 'none';
                document.getElementById('loading').style.display = 'block';
                document.getElementById('loading').innerHTML = `
                    <div style="display: inline-block; animation: spin 1s linear infinite; font-size: 16px; margin-right: 5px;">⟳</div>
                    <span>Looking up "${word}"...</span>
                `;

                // Set a safety timeout to ensure the loading message doesn't get stuck
                const safetyTimeout = setTimeout(() => {

                    document.getElementById('loading').style.display = 'none';
                }, 5000); // 5 second timeout

                try {
                    // Variables for lookup
                    let termId = null;
                    let intermediateFormFound = false;
                    let lookupKey = word.trim();

                    // Convert to intermediate form first, then apply anusvarafy
                    let intermediateForm = anusvarafy(devanagariToIntermediate(lookupKey));


                    // Use the intermediate form for lookup
                    lookupKey = intermediateForm;

                    // Check if we have parsed table data
                    if (parsedTableData && parsedTableData.length > 0) {
                        // Use binary search to find the exact match
                        const startIndex = findFirstGreaterOrEqual(lookupKey);
                        if (startIndex !== -1 && parsedTableData[startIndex][0] === lookupKey) {
                            // Found an exact match
                            termId = parsedTableData[startIndex][1];
                            intermediateFormFound = true;
                        }
                    } else if (typeof preloadedTableData !== 'undefined') {
                        // Search for the word in the preloaded table data
                        for (const line of preloadedTableData) {
                            if (!line.trim()) continue;

                            const parts = line.split(':').map(part => part.trim());
                            if (parts.length >= 2 && parts[0] === lookupKey) {
                                // Found a match, extract the term ID (second field)
                                const id = parseInt(parts[1], 10);
                                if (!isNaN(id)) {
                                    termId = id;
                                    intermediateFormFound = true;

                                    break;
                                }
                            }
                        }
                    } else {
                        throw new Error('parsedTable or preloadedTable not found');
                    }

                    if (termId) {
                        // Clear the safety timeout since we're navigating to the term
                        clearTimeout(safetyTimeout);

                        // Update URL to show the word being looked up
                        const newUrl = new URL(window.location.href);
                        // Clear any existing parameters
                        Array.from(newUrl.searchParams.keys()).forEach(key => {
                            newUrl.searchParams.delete(key);
                        });
                
                        //wordDev = r.expanded_banner = Sanscript.t(word, 'slp1', 'devanagari');


                        
                        // Navigate to the term
                        resetAndLoadAndRenderTermsFrom(termId, word, deleteTextQueryResults = true).finally(() => {
                            resolve();
                        });
                    } else {
                        // Word not found
                        clearTimeout(safetyTimeout);
                        document.getElementById('loading').style.display = 'none';

                        // Hide keyboard hints
                        document.getElementById('keyboard-hint-top').style.display = 'none';
                        document.getElementById('keyboard-hint-bottom').style.display = 'none';

                        // Always reject with information about the attempt
                        reject({
                            word: word,
                            originalWord: originalWord,
                            isSLP1Input: isSLP1Input,
                            isAlternativeAttempt: isAlternativeAttempt,
                            message: `Word "${isSLP1Input ? originalWord : word}" not found in dictionary.`
                        });
                    }
                } catch (error) {
                    clearTimeout(safetyTimeout);

                    document.getElementById('loading').style.display = 'none';
                    document.getElementById('error').style.display = 'block';
                    document.getElementById('error').textContent = `Error looking up word :- ${error.message}`;
                    document.getElementById('keyboard-hint-top').style.display = 'none';
                    document.getElementById('keyboard-hint-bottom').style.display = 'none';
                    reject(error);
                }
            });
        }

        // Function to render suggestions
        function renderSuggestions(suggestions) {
            const suggestionsContainer = document.getElementById('suggestions-container');

            // Clear previous suggestions
            suggestionsContainer.innerHTML = '';

            if (suggestions.length === 0) {
                suggestionsContainer.style.display = 'none';
                return;
            }

            // Create suggestion items
            suggestions.forEach(suggestion => {
                const item = document.createElement('div');
                item.className = 'suggestion-item';
                item.innerHTML = `<span class="suggestion-text">${suggestion}</span>`;

                // Add click event to select this suggestion
                item.addEventListener('click', () => {
                    // Set the input value to the selected suggestion
                    document.getElementById('user-input').value = suggestion;

                    // Hide suggestions
                    suggestionsContainer.style.display = 'none';

                    // Check if we have the entry ID for this suggestion
                    const entryInfo = suggestionToEntryMap.get(suggestion);
                    if (entryInfo && entryInfo.id) {
                        // Create a custom lookup function for the suggestion
                        async function lookupSuggestion() {
                            try {
                                // Show loading message
                                document.getElementById('error').style.display = 'none';
                                document.getElementById('loading').style.display = 'block';
                                document.getElementById('loading').innerHTML = `
                                    <div style="display: inline-block; animation: spin 1s linear infinite; font-size: 16px; margin-right: 5px;">⟳</div>
                                    <span>Looking up "${suggestion}"...</span>
                                `;

                                // Use the term ID directly from the entry info
                                await resetAndLoadAndRenderTermsFrom(entryInfo.id, suggestion, deleteTextQueryResults=true);

                                // Hide loading message
                                document.getElementById('loading').style.display = 'none';
                            }
                            catch (error) {
                                console.error(error.stack);
                            }
                        };
                        lookupSuggestion();
                    } else {
                        // Fallback to regular lookup if entry info is not available
                        lookupDevanagariWord(suggestion).catch(error => {
                        });
                    }

                    // Defocus the input field
                    document.getElementById('user-input').blur();
                });

                suggestionsContainer.appendChild(item);
            });

            // Show the suggestions container
            suggestionsContainer.style.display = 'block';
        }

        // Function to update the selected suggestion
        function updateSelectedSuggestion(suggestionItems) {
            // Remove highlight from all items
            suggestionItems.forEach(item => {
                item.style.backgroundColor = '';
            });

            // Add highlight to selected item
            if (selectedSuggestionIndex >= 0 && selectedSuggestionIndex < suggestionItems.length) {
                suggestionItems[selectedSuggestionIndex].style.backgroundColor = '#f0f0f0';

                // Ensure the selected item is visible in the container
                suggestionItems[selectedSuggestionIndex].scrollIntoView({ block: 'nearest' });
            }
        }

        async function loadAndRenderNextTerm(termId, direction) {
            if (isLoading || !termId || termId < 1) return Promise.resolve();

            // Check if this term is already loaded
            if (document.querySelector(`.term-container[data-term-id="${termId}"]`)) {
                return Promise.resolve();
            }

            try {
                isLoading = true;
                // Load the term
                const termData = await loadSingleTerm(termId);
                if (termData) {
                    // Double-check that the term hasn't been added while we were loading
                    if (document.querySelector(`.term-container[data-term-id="${termId}"]`)) {
                        // console.log(`Term ${termId} was added while loading, skipping`);
                        isLoading = false;
                        return;
                    }

                    // Get the terms container
                    const termsContainer = document.getElementById('terms-container');

                    // Create a container for this term
                    const termContainer = document.createElement('div');
                    termContainer.className = 'term-container';
                    termContainer.dataset.termId = termId;

                    // Add highlighting class if this is the requested term
                    if (termId === requestedTermId) {
                        termContainer.classList.add('highlighted');
                    }

                    // Check if it's a placeholder
                    if (termData[0].__placeholder) {
                        termContainer.innerHTML = `<div class="term-row"><em>Term ${termId} not available</em></div>`;
                    } else {
                        // Render the term
                        termContainer.innerHTML = termData.map(term => processTerm(term)).join('');
                    }

                    // Add term ID as a clickable link
                    termContainer.appendChild(createPdfLink(termContainer, termId));

                    // Add to the DOM in the appropriate position
                    if (direction === 'above') {
                        // Save current scroll position and document height
                        const oldScrollY = window.scrollY;
                        const oldDocumentHeight = document.documentElement.scrollHeight;

                        // Add the new term at the top
                        termsContainer.insertBefore(termContainer, termsContainer.firstChild);
                        // const lowestLoadedId = getLowestLoadedId();
                        // console.log(`added ${termId}`, { lowestLoadedId, isLoadingTop: window.termViewerState.isLoadingTop }, `loadedTermIds range: ${loadedTermIds.size > 0 ? Math.min(...loadedTermIds) : 'empty'}-${loadedTermIds.size > 0 ? Math.max(...loadedTermIds) : 'empty'}`);

                        // Wait for the DOM to update
                        setTimeout(() => {
                            // Calculate how much the document height changed
                            const newDocumentHeight = document.documentElement.scrollHeight;
                            const heightDifference = newDocumentHeight - oldDocumentHeight;

                            // Adjust scroll position to maintain the same view
                            if (heightDifference > 0) {
                                // Special case: if we were at the top (scrollY === 0), don't adjust scroll position
                                // This allows the user to see the newly loaded content at the top
                                if (oldScrollY === 0) {
                                    // console.log('At top of page, not adjusting scroll position to show new content');
                                } else {
                                    // Otherwise, maintain the same view by adjusting scroll position
                                    window.scrollTo(0, oldScrollY + heightDifference);
                                    // console.log(`Adjusted scroll position by ${heightDifference}px (from ${oldScrollY} to ${oldScrollY + heightDifference})`);
                                }
                            }
                        }, 0);
                    } else {
                        termsContainer.appendChild(termContainer);
                    }

                    // Trim excess terms to maintain the window size
                    // trimExcessTerms();
                }

                isLoading = false;
                return Promise.resolve();
            } catch (error) {
                console.error(`Error loading more terms:`, error);
                isLoading = false;
                return Promise.reject(error);
            }
        }

        // --- Full-text query helpers ---
        const TEXT_QUERY_PAGE_SIZE = 50;
        // let currentTextQuery = '';

        async function makeTextQuery(q, offset = 0) {
            // currentTextQuery = q;

            console.log(`Firing /text-query for: ${q} (offset=${offset})`);
            fetch(`/text-query?q=${encodeURIComponent(q)}&from=${offset}`)
                .then(resp => resp.json())
                .then(json => {
                    console.log('Text-query response:', json);
                    json.results.forEach(r => {
                        r.expanded_banner = Sanscript.t(r.expanded_banner, 'slp1', 'devanagari');
                        r.nested_term_id = parseInt(r.ancestry.split('L_')[1].split('/')[0].trim());
                    });

                    renderTextQueryResults(json.results, q, offset);
                })
                .catch(err => console.error('Text-query error:', err));
        }

        // Render full-text search results with pagination
        function renderTextQueryResults(results, queriedWord, offset) {
            const resultsContainer = document.getElementById('text-query-results-container');
            resultsContainer.style.display = 'block'; // Show text-query results container
            
            if (!resultsContainer) return;
            // Clear previous results
            resultsContainer.innerHTML = '';

            if (!results || results.length === 0) {
                resultsContainer.innerHTML = `<div class="no-results">No matches found for ${queriedWord}</div>`;
                return;
            }

            // Introductory phrase
            const intro = document.createElement('div');
            intro.className = 'results-intro';
            intro.textContent = `Found ${queriedWord} in the following entries:`;
            resultsContainer.appendChild(intro);

            // Create a fragment to hold all result items
            const fragment = document.createDocumentFragment();

            results.forEach(r => {
                // Container for a single result pair
                const pair = document.createElement('div');
                pair.className = 'result-item';

                // Expanded banner (highlighted)
                const bannerSpan = document.createElement('span');
                bannerSpan.className = 'result-banner';
                bannerSpan.innerHTML = r.expanded_banner + ' ';

                // Snippet (less prominent)
                const snippetSpan = document.createElement('span');
                snippetSpan.className = 'result-snippet';
                snippetSpan.innerHTML = r.snippet;

                pair.appendChild(bannerSpan);
                // pair.appendChild(snippetSpan);

                pair.addEventListener('click', () => {
                    // Navigate directly to the clicked term
                    resetAndLoadAndRenderTermsFrom(r.nested_term_id, queriedWord, deleteTextQueryResults = false, textQueryFlow=true)
                        .catch(err => console.error('Navigation error:', err));
                });

                fragment.appendChild(pair);
            });

            resultsContainer.appendChild(fragment);

            // --- Pagination controls ---
            const pagDiv = document.createElement('div');
            pagDiv.className = 'pagination';

            const prevBtn = document.createElement('button');
            prevBtn.textContent = '<';
            prevBtn.disabled = offset === 0;
            prevBtn.addEventListener('click', () => {
                if (offset >= TEXT_QUERY_PAGE_SIZE) {
                    makeTextQuery(queriedWord, offset - TEXT_QUERY_PAGE_SIZE);
                }
            });

            const nextBtn = document.createElement('button');
            nextBtn.textContent = '>';
            // Disable next if fewer than page size returned (no more pages)
            nextBtn.disabled = results.length < TEXT_QUERY_PAGE_SIZE;
            nextBtn.addEventListener('click', () => {
                if (results.length === TEXT_QUERY_PAGE_SIZE) {
                    makeTextQuery(queriedWord, offset + TEXT_QUERY_PAGE_SIZE);
                }
            });

            const rangeStart = offset + 1;
            const rangeEnd = offset + results.length;
            pagDiv.appendChild(prevBtn);
            pagDiv.appendChild(document.createTextNode(`  ${rangeStart}-${rangeEnd}  `));
            pagDiv.appendChild(nextBtn);

            resultsContainer.appendChild(pagDiv);
        }

        // As user types in, show suggestions
        document.getElementById('user-input').addEventListener('input', function () {
            const input = this.value.trim();

            if (input.length < 1 || input.startsWith(meaningSearchBeginner)) {
                // Hide suggestions if input is too short or is a meanings search
                document.getElementById('suggestions-container').style.display = 'none';
                return;
            }

            // Check if input is likely in SLP1 format
            let processedInput = input;
            if (isLikelySLP1(input)) {
                try {
                    // Convert SLP1 to Devanagari for suggestions
                    processedInput = Sanscript.t(input, 'slp1', 'devanagari');
                } catch (e) {
                    console.error(`Error converting SLP1 to Devanagari for suggestions: ${e.message}`);
                    // Continue with original input if conversion fails
                    processedInput = input;
                }
            }

            // Get suggestions based on processed input
            const suggestions = getSuggestions(processedInput);

            // Render suggestions
            renderSuggestions(suggestions);
        });

        // Hide suggestions when clicking outside
        document.addEventListener('click', function (event) {
            const suggestionsContainer = document.getElementById('suggestions-container');
            const inputField = document.getElementById('user-input');

            if (!suggestionsContainer.contains(event.target) && event.target !== inputField) {
                suggestionsContainer.style.display = 'none';
            }
        });

        // Search button
        document.getElementById('search-button').addEventListener('click', function () {
            const inputField = document.getElementById('user-input');
            const word = inputField.value.trim();

            // Handle "/"-prefixed full-text search
            if (word.startsWith(meaningSearchBeginner)) {
                const q = word.slice(1);
                if (q.length > 1) {
                    makeTextQuery(q, 0);
                }
                // Always hide suggestions
                document.getElementById('suggestions-container').style.display = 'none';
            } else {
                // Try to look up the word as entered (not an alternative attempt)
                lookupDevanagariWord(word, false).catch(error => {
                    // Check if this was an original word attempt (not an alternative)
                    if (!error.isAlternativeAttempt) {
                        // Use the converted Devanagari word for range check
                        const wordToCheck = error.word; // This is the converted Devanagari word
                        const displayWord = error.isSLP1Input ? error.originalWord : error.word;
                        // Check if the last character is in the range [अ, ौ]
                        const lastChar = wordToCheck.charAt(wordToCheck.length - 1);
                        const isInRange = lastChar >= 'अ' && lastChar <= 'ौ';
                        if (isInRange) {
                            // Try with visarga (ः) appended
                            const wordWithVisarga = wordToCheck + 'ः';
                            lookupDevanagariWord(error.isSLP1Input ? error.originalWord + "H" : wordWithVisarga, true).catch(visargaError => {
                                // Try with anusvara (ं) appended
                                const wordWithAnusvara = wordToCheck + 'ं';
                                lookupDevanagariWord(error.isSLP1Input ? error.originalWord + "M" : wordWithAnusvara, true).catch(anusvaraError => {
                                    // All attempts failed - now show the error message
                                    document.getElementById('error').style.display = 'block';
                                    document.getElementById('error').innerHTML = `Word "${displayWord}" not found in dictionary.`;
                                });
                            });
                        } else {
                            // Not in range for alternatives - show error immediately
                            document.getElementById('error').style.display = 'block';
                            document.getElementById('error').innerHTML = error.message;
                        }
                    } else {
                        // This was already an alternative attempt - just log the failure
                    }
                });
            }
            document.getElementById('suggestions-container').style.display = 'none';
            // Defocus the input field to allow normal scrolling with arrow keys
            inputField.blur();
        });

        // Up, down, escape keys in input should navigate/hide suggestions
        document.getElementById('user-input').addEventListener('keydown',
            function (event) {
                const suggestionsContainer = document.getElementById('suggestions-container');
                const suggestionItems = suggestionsContainer.querySelectorAll('.suggestion-item');

                // Only process if suggestions are visible
                if (suggestionsContainer.style.display === 'block') {
                    if (event.key === 'ArrowDown') {
                        // Move selection down
                        event.preventDefault();
                        selectedSuggestionIndex = Math.min(selectedSuggestionIndex + 1, suggestionItems.length - 1);
                        updateSelectedSuggestion(suggestionItems);
                    } else if (event.key === 'ArrowUp') {
                        // Move selection up
                        event.preventDefault();
                        selectedSuggestionIndex = Math.max(selectedSuggestionIndex - 1, -1);
                        updateSelectedSuggestion(suggestionItems);
                    } else if (event.key === 'Escape') {
                        // Hide suggestions on Escape
                        event.preventDefault();
                        suggestionsContainer.style.display = 'none';
                        selectedSuggestionIndex = -1;
                    }
                }
            }
        );

        // Enter key should submit
        document.getElementById('user-input').addEventListener('keypress', function (event) {
            if (event.key === 'Enter') {
                event.preventDefault();

                const suggestionsContainer = document.getElementById('suggestions-container');
                const suggestionItems = suggestionsContainer.querySelectorAll('.suggestion-item');

                // If suggestions are visible and an item is selected, use that
                if (suggestionsContainer.style.display === 'block' &&
                    selectedSuggestionIndex >= 0 &&
                    selectedSuggestionIndex < suggestionItems.length) {

                    // Simulate click on the selected suggestion
                    suggestionItems[selectedSuggestionIndex].click();
                    return;
                } else {
                    // Simulate click on the input itself
                    document.getElementById('search-button').click();
                }

            }
        });

        // Up, down keys outside input should scroll the page
        window.addEventListener('keydown', function (event) {
            // Handle up arrow key when at the top
            if (window.scrollY === 0 && (event.key === 'ArrowUp' || event.key === 'Up')) {

                // Check if we're in a term view context
                if (loadedTermIds.size > 0 && Math.min(...loadedTermIds) > 1 && !isLoadingTop) {

                    // Force loading of previous terms
                    // Check if the terms immediately before the lowest loaded term are already in the DOM
                    let prevTermId = Math.min(...loadedTermIds) - 1;

                    // If the previous terms are already loaded, go back further
                    while (prevTermId > 1 && document.querySelector(`.term-container[data-term-id="${prevTermId}"]`)) {
                        prevTermId--;
                    }

                    // Calculate batch start, ensuring we don't go below 1
                    const batchStartId = Math.max(1, prevTermId - 7 + 1); // Use BATCH_SIZE (7)

                    // Show loading indicator
                    document.getElementById('loading-top').style.display = 'block';
                    isLoadingTop = true;

                    // Load each term in the batch, but only if it's not already in the DOM
                    const loadPromises = [];
                    for (let id = prevTermId; id >= batchStartId; id--) {
                        // Skip terms that are already in the DOM
                        if (!document.querySelector(`.term-container[data-term-id="${id}"]`)) {
                            loadPromises.push(loadAndRenderNextTerm(id, 'above'));
                        }
                    }

                    // Hide loading indicator when all terms are loaded
                    if (loadPromises.length > 0) {
                        Promise.all(loadPromises).finally(() => {
                            setTimeout(() => {
                                document.getElementById('loading-top').style.display = 'none';
                                isLoadingTop = false;
                            }, 300);
                        });
                    } else {
                        // If no terms were loaded, hide the indicator
                        setTimeout(() => {
                            document.getElementById('loading-top').style.display = 'none';
                            isLoadingTop = false;
                        }, 300);
                    }
                }
            }

            // Handle down arrow key when at the bottom
            if ((window.innerHeight + window.scrollY >= document.body.offsetHeight - 5) &&
                (event.key === 'ArrowDown' || event.key === 'Down')) {
                // Check if we're in a term view context and not already loading
                const termContainers = document.querySelectorAll('.term-container');
                if (termContainers.length > 0 && !isLoadingBottom) {
                    // Get the highest loaded term ID
                    const loadedIds = Array.from(termContainers).map(container =>
                        parseInt(container.dataset.termId, 10)).sort((a, b) => a - b);
                    const highestLoadedId = loadedIds.length > 0 ? loadedIds[loadedIds.length - 1] : currentTermId;

                    // Force reset lastBottomTermId to allow loading
                    // lastBottomTermId = null;

                    // Force loading of next terms
                    const nextTermId = highestLoadedId + 1;
                    const batchEndId = nextTermId + BATCH_SIZE - 1;

                    // Show loading indicator
                    document.getElementById('loading-bottom').style.display = 'block';
                    isLoadingBottom = true;

                    // Load each term in the batch
                    const loadPromises = [];
                    for (let id = nextTermId; id <= batchEndId; id++) {
                        // Skip terms that are already in the DOM
                        if (!document.querySelector(`.term-container[data-term-id="${id}"]`)) {
                            loadPromises.push(loadAndRenderNextTerm(id, 'below'));
                        }
                    }

                    // Hide loading indicator when all terms are loaded
                    if (loadPromises.length > 0) {
                        Promise.all(loadPromises).finally(() => {
                            setTimeout(() => {
                                document.getElementById('loading-bottom').style.display = 'none';
                                isLoadingBottom = false;
                            }, 300);
                        });
                    } else {
                        // If no terms were loaded, hide the indicator
                        setTimeout(() => {
                            document.getElementById('loading-bottom').style.display = 'none';
                            isLoadingBottom = false;
                        }, 300);
                    }
                }
            }
        });

        // Load data based on URL parameters
        document.addEventListener('DOMContentLoaded', function () {
            console.log('1.0');
            // Set focus on the input box
            document.getElementById('user-input').focus();

            // Fix cursor position when clicking on the input field
            document.getElementById('user-input').addEventListener('click', function (event) {
                // If the click position is after the text content, move cursor to the end
                const inputRect = this.getBoundingClientRect();
                const clickX = event.clientX - inputRect.left;
                const textWidth = this.value.length > 0 ?
                    this.scrollWidth - (this.offsetWidth - this.clientWidth) : 0;

                // If clicked in the empty space (right side of text), move cursor to the end
                if (clickX > textWidth) {
                    this.setSelectionRange(this.value.length, this.value.length);
                }
            });

            // Set header-spacer height to match the header height
            const headerHeight = document.getElementById('header').offsetHeight;
            document.getElementById('header-spacer').style.height = headerHeight + 'px';

            // Update header-spacer height on window resize
            window.addEventListener('resize', function () {
                const headerHeight = document.getElementById('header').offsetHeight;
                document.getElementById('header-spacer').style.height = headerHeight + 'px';
            });

            // Check if we have preloaded table data
            if (typeof preloadedTableData !== 'undefined') {
                console.log(`Preloaded table data available with ${preloadedTableData.length} entries`); // KEEP

                // Parse the preloaded table data into arrays
                parsedTableData = preloadedTableData.map(line => {
                    if (!line.trim()) return null;
                    const parts = line.split(':').map(part => part.trim());
                    if (parts.length >= 3) {
                        return [parts[0], parseInt(parts[1], 10), parts[2]];
                    } else if (parts.length >= 2) {
                        return [parts[0], parseInt(parts[1], 10), ''];
                    }
                    return null;
                }).filter(item => item !== null);

                console.log(`Parsed table data into ${parsedTableData.length} arrays`);//KEEP

                // Show a brief message that the dictionary is ready
                document.getElementById('loading').style.display = 'block';
                document.getElementById('loading').innerHTML = `
                    <div style="display: inline-block; font-size: 16px; margin-right: 5px;">✓</div>
                    <span>Dictionary data loaded (${parsedTableData.length} entries)</span>
                `;

                // Hide the message after a short delay
                setTimeout(() => {
                    document.getElementById('loading').style.display = 'none';
                }, 1500);
            } else {
                console.log('Error: preloadedTableData is undefined');
                return;
            }

            // Make sure loading indicators are hidden initially
            document.getElementById('loading-top').style.display = 'none';
            document.getElementById('loading-bottom').style.display = 'none';
            document.getElementById('keyboard-hint-top').style.display = 'none';
            document.getElementById('keyboard-hint-bottom').style.display = 'none';

        });
    </script>
</body>

</html>