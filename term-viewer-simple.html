<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Term Viewer</title>
    <script src="sanscript.js"></script>
    <style>
        body {
            font-family: 'Arial', sans-serif;
            line-height: 1.6;
            margin: 0;
            padding: 20px;
            background-color: #f5f5f5;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .scroll-loading-indicator {
            position: fixed;
            left: 50%;
            transform: translateX(-50%);
            width: auto; /* Auto width to fit content */
            min-width: 40px; /* Minimum width */
            text-align: center;
            padding: 6px 10px; /* Reduced padding */
            background-color: rgba(255, 255, 255, 0.95);
            border: 1px solid #4CAF50;
            font-size: 14px;
            color: #333;
            z-index: 90;
            display: none;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            border-radius: 20px;
        }

        #loading-top {
            top: 80px; /* Just below the header */
        }

        #loading-bottom {
            bottom: 20px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding-left: 40px; /* Make room for term IDs */
        }

        h1 {
            text-align: center;
            margin-bottom: 20px;
        }

        .term-row {
            background-color: white;
            padding: 12px;
            margin-bottom: 0;
            overflow-wrap: break-word;
            word-wrap: break-word;
            hyphens: auto;
        }

        /* Line number styling removed */

        .ancestry {
            display: inline;
            color: #555;
            font-style: italic;
            margin-right: 10px;
        }

        .banner {
            display: inline;
            font-weight: bold;
            margin-right: 10px;
            position: relative;
            cursor: default; /* Use default cursor instead of help */
        }

        /* Tooltip for banner */
        .banner::after {
            content: attr(data-tooltip);
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            background-color: #333;
            color: white;
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 0.8em;
            white-space: nowrap;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.2s, visibility 0.2s;
            z-index: 100;
        }

        .banner:hover::after {
            opacity: 1;
            visibility: visible;
        }

        .gram {
            display: inline;
            color: #0066cc;
            margin-right: 10px;
        }

        .meaning {
            display: inline;
            margin-right: 10px;
            cursor: default; /* Use default cursor instead of pointer */
        }

        /* Add hover effect for banner and meaning */
        .banner:hover, .meaning:hover {
            background-color: rgba(0, 0, 0, 0.05); /* Mild highlight on hover */
            border-radius: 2px;
        }

        .meaning-number {
            font-weight: bold;
        }

        .special-text {
            color: #9c7c38; /* Teak wood color - matching Devanagari */
            font-style: italic;
        }

        .devanagari {
            font-family: 'Noto Sans Devanagari', 'Sanskrit 2003', sans-serif;
            font-size: 1.1em;
            color: #9c7c38; /* Teak wood color - warm golden brown */
            font-weight: 500; /* Slightly bolder for better readability */
        }

        /* Smaller font for Devanagari text within meaning elements */
        .meaning .devanagari {
            font-size: 0.95em;
        }

        .warning-symbol {
            color: red;
            font-weight: bold;
        }

        .loading {
            text-align: center;
            padding: 5px;
            font-size: 0.9em;
            color: #666;
            width: auto;
            max-width: 200px;
            margin: 10px auto;
        }

        .scroll-loading-indicator {
            text-align: center;
            padding: 3px;
            font-size: 0.8em;
            color: #888;
            width: auto;
            max-width: 100px;
            margin: 5px auto;
            display: none;
        }

        .error {
            color: #d32f2f;
            text-align: center;
            padding: 10px;
            font-size: 1.1em;
            width: auto;
            max-width: 300px;
            margin: 20px auto;
            background-color: rgba(255, 255, 255, 0.95);
            border: 1px solid #d32f2f;
            border-radius: 20px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        }

        /* Nested term sections */
        .nested-term {
            display: inline;
            position: relative;
            border-radius: 3px;
            border: 1px solid transparent;
            padding: 1px 2px;
            margin: 0 1px;
            cursor: default; /* Use default cursor instead of pointer */
        }

        /* Add hover effect for nested terms */
        .nested-term:hover {
            background-color: rgba(0, 0, 0, 0.05); /* Mild highlight on hover */
        }

        /* Left border only for nested terms */
        .nested-morphism {
            border-color: transparent;
            border-left: 3px solid rgba(0, 100, 200, 0.3);
            background-color: transparent;
            padding-left: 4px;
        }

        .nested-samasa {
            border-color: transparent;
            border-left: 3px solid rgba(150, 0, 200, 0.3);
            background-color: transparent;
            padding-left: 4px;
        }

        /* Nested items with different nesting levels */
        /* Level 0 (first level) */
        .nested-morphism[data-nesting-level="0"] {
            border-left: 3px solid rgba(0, 100, 200, 0.3);
            margin-left: 2px;
        }

        .nested-samasa[data-nesting-level="0"] {
            border-left: 3px solid rgba(150, 0, 200, 0.3);
            margin-left: 2px;
        }

        /* Level 1 (second level) */
        .nested-morphism[data-nesting-level="1"] {
            border-left: 3px solid rgba(0, 100, 200, 0.5);
            margin-left: 2px;
        }

        .nested-samasa[data-nesting-level="1"] {
            border-left: 3px solid rgba(150, 0, 200, 0.5);
            margin-left: 2px;
        }

        /* Level 2 (third level) */
        .nested-morphism[data-nesting-level="2"] {
            border-left: 3px solid rgba(0, 100, 200, 0.7);
            margin-left: 2px;
        }

        .nested-samasa[data-nesting-level="2"] {
            border-left: 3px solid rgba(150, 0, 200, 0.7);
            margin-left: 2px;
        }

        /* Level 3+ (fourth level and beyond) */
        .nested-morphism[data-nesting-level="3"],
        .nested-morphism[data-nesting-level="4"] {
            border-left: 3px solid rgba(0, 100, 200, 0.9);
            margin-left: 2px;
        }

        .nested-samasa[data-nesting-level="3"],
        .nested-samasa[data-nesting-level="4"] {
            border-left: 3px solid rgba(150, 0, 200, 0.9);
            margin-left: 2px;
        }

        /* Cross-nested items (morphism in samasa or vice versa) */
        .nested-term .nested-term {
            margin-left: 2px;
        }

        /* Hover effect - slightly darker left border */
        .nested-morphism:hover {
            border-left-color: rgba(0, 100, 200, 0.8);
        }

        .nested-samasa:hover {
            border-left-color: rgba(150, 0, 200, 0.8);
        }

        /* Pagination */
        .pagination {
            display: flex;
            justify-content: center;
            margin: 20px 0;
        }

        .pagination button {
            background-color: #4CAF50;
            color: white;
            border: none;
            padding: 8px 16px;
            margin: 0 5px;
            cursor: pointer;
            border-radius: 4px;
        }

        .pagination button:disabled {
            background-color: #cccccc;
            cursor: not-allowed;
        }

        .pagination-info {
            margin: 0 15px;
            line-height: 32px;
        }

        /* Styling for infinite scroll */
        .term-container {
            margin-bottom: 0;
            position: relative;
            border-top: 1px solid #e0e0e0;
        }

        .term-container:first-child {
            border-top: none;
        }

        /* Highlighting for the looked-up term */
        .term-container.highlighted {
            background: linear-gradient(to right, rgba(235, 248, 255, 0.3) 0%, rgba(240, 249, 255, 0.1) 100%); /* Subtle gradient background */
            border-left: 2px solid rgba(49, 130, 206, 0.5); /* Subtle blue left border */
            margin-left: -2px; /* Offset the border to maintain alignment */
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.05); /* Very subtle shadow */
            position: relative;
            padding-top: 3px; /* Reduced padding */
            padding-bottom: 3px; /* Reduced padding */
            margin-top: 2px; /* Reduced space above */
            margin-bottom: 2px; /* Reduced space below */
            border-radius: 2px; /* Subtle rounded corners */
        }

        .term-container.highlighted .term-row {
            background: transparent; /* Make the row background transparent to show the container gradient */
        }

        .term-container.highlighted .banner {
            font-weight: 500; /* Semi-bold instead of bold */
            color: #2b6cb0; /* Brighter blue for the banner */
            text-decoration: none; /* No underline */
            font-size: 1em; /* Normal font size */
        }

        .term-container.highlighted .meaning {
            color: #2d3748; /* Slightly darker than normal text */
            font-weight: normal; /* Normal weight */
        }

        /* Specific highlighting for nested elements that match the search */
        .nested-term.search-match {
            background-color: rgba(252, 241, 184, 1); /* Very light yellow background */
            padding: 2px 4px;
            margin: 0 2px;
            border-radius: 2px;
        }

        .nested-term.search-match .banner,
        .nested-term.search-match .meaning {
            color: #7c2d12; /* Dark orange-brown */
            font-weight: 500; /* Semi-bold instead of bold */
        }

        .term-container::before {
            content: attr(data-term-id);
            position: absolute;
            left: -40px;
            top: 15px;
            color: #999;
            font-size: 0.9em;
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- Header with search functionality - fixed at top -->
        <div id="header" style="position: fixed; top: 0; left: 0; right: 0; background-color: #f5f5f5; box-shadow: 0 2px 5px rgba(0,0,0,0.1); padding: 15px; z-index: 100;">
            <div id="file-selector" style="text-align: center;">
                <div style="display: flex; justify-content: center; align-items: center;">
                    <div style="display: flex; align-items: center;">
                        <input type="text" id="devanagari-input" placeholder="Enter Devanagari or SLP1 Word (e.g., अंकः or aMkaH)" style="padding: 8px; width: 300px; margin-right: 10px;">
                        <button id="lookup-devanagari" style="background-color: #4CAF50; color: white; border: none; padding: 8px 16px; cursor: pointer; border-radius: 4px;">Look Up</button>
                    </div>
                </div>
            </div>
            <!-- Hidden pagination controls -->
            <div style="display: none;">
                <span id="pagination-info">Page 1</span>
                <button id="prev-page" disabled>Previous</button>
                <button id="next-page">Next</button>
            </div>
        </div>

        <!-- Spacer to push content below the fixed header -->
        <div id="header-spacer"></div>

        <!-- Main content area -->
        <div id="content-area">
            <!-- Loading indicator -->
            <div id="loading" class="loading">
                <div style="display: inline-block; animation: spin 1s linear infinite; font-size: 16px; margin-right: 5px;">⟳</div>
                <span>Loading...</span>
            </div>

            <!-- Error message -->
            <div id="error" class="error" style="display: none;"></div>

            <!-- Keyboard navigation hint for top of page -->
            <div id="keyboard-hint-top" style="text-align: center; margin: 5px 0; font-size: 12px; color: #777; display: none;">
                Hit the ↑ key to see previous entries
            </div>

            <!-- Terms container -->
            <div id="terms-container"></div>

            <!-- Scroll loading indicators -->
            <div id="load-more-top-button" style="text-align: center; margin: 10px 0; display: none;">
                <button id="load-more-top" style="background-color: #4CAF50; color: white; border: none; padding: 8px 16px; cursor: pointer; border-radius: 4px;">Load More Above ▲</button>
            </div>

            <div id="loading-top" class="scroll-loading-indicator">
                <div style="display: inline-block; animation: spin 1s linear infinite; font-size: 14px; margin-right: 3px;">⟳</div>
                <span>Loading...</span>
            </div>
            <div id="loading-bottom" class="scroll-loading-indicator">
                <div style="display: inline-block; animation: spin 1s linear infinite; font-size: 14px; margin-right: 3px;">⟳</div>
                <span>Loading...</span>
            </div>

            <!-- Keyboard navigation hint for bottom of page -->
            <div id="keyboard-hint-bottom" style="text-align: center; margin: 5px 0; font-size: 12px; color: #777; display: none;">
                Hit the ↓ key to see more entries
            </div>
        </div>
    </div>

    <script>
        // Configuration
        const PAGE_SIZE = 20;
        let currentPage = 0;
        let termsData = [];
        let pagemarks = {}; // Will store the pagemarks data
        let sortedPagemarkKeys = []; // Will store the sorted keys for binary search
        let currentTermId = null; // Current term ID being viewed
        let requestedTermId = null; // Track the term that was specifically requested
        let searchedWord = null; // Store the Devanagari word that was searched
        let isLoading = false; // Flag to prevent multiple simultaneous loads

        // Infinite scroll configuration`
        const WINDOW_SIZE = 16; // Current term + 15 after
        const WINDOW_BEFORE = 0; // 0 terms before
        const WINDOW_AFTER = 15; // 15 terms after
        let loadedTerms = {}; // Map of termId -> term data
        let loadedTermIds = new Set(); // Set of loaded term IDs

        // Base URL for page links
        const PAGE_URL_BASE = "https://www.sanskrit-lexicon.uni-koeln.de/scans/csl-apidev/servepdf.php?dict=AP90&page=";

        // Function to process special text formatting
        function processSpecialText(text) {
            if (!text) return '';

            // Convert SLP1 encoded Sanskrit text in {# #} brackets to Devanagari
            text = text.replace(/\{#(.*?)#\}/g, function(match, p1) {
                try {
                    // Convert SLP1 to Devanagari
                    const devanagari = Sanscript.t(p1, 'slp1', 'devanagari');
                    return `<span class="devanagari">${devanagari}</span>`;
                } catch (e) {
                    // If conversion fails, just return the original text with special styling
                    return `<span class="special-text">${p1}</span>`;
                }
            });

            // Remove {% %} brackets but style the content differently
            text = text.replace(/\{%(.*?)%\}/g, '<span class="special-text">$1</span>');

            // Remove <ab> </ab> tags but style the content differently
            text = text.replace(/<ab>(.*?)<\/ab>/g, '<span class="special-text">$1</span>');

            return text;
        }

        // Function to process special text formatting without special styling (for banner text)
        function processPlainText(text) {
            if (!text) return '';

            // Convert SLP1 encoded Sanskrit text in {# #} brackets to Devanagari
            text = text.replace(/\{#(.*?)#\}/g, function(match, p1) {
                try {
                    // Convert SLP1 to Devanagari
                    return Sanscript.t(p1, 'slp1', 'devanagari');
                } catch (e) {
                    // If conversion fails, just return the original text
                    return p1;
                }
            });

            // Remove {% %} brackets without special styling
            text = text.replace(/\{%(.*?)%\}/g, '$1');

            // Remove <ab> </ab> tags without special styling
            text = text.replace(/<ab>(.*?)<\/ab>/g, '$1');

            return text;
        }

        // Function to process meaning text with numbered meanings
        function processMeaning(text) {
            if (!text) return '';

            // Normalize all whitespace (including newlines) to a single space
            text = text.replace(/\s+/g, ' ');

            // Handle {@--n@} format at the beginning of meanings
            text = text.replace(/\{@--(\d+)@\}/g, '<span class="meaning-number">$1</span> ');

            // Handle {n} format at the beginning of meanings
            text = text.replace(/^\{(\d+)\}\s*/g, '<span class="meaning-number">$1</span> ');

            return text;
        }

        // Function to process banner expansion
        function processBannerExp(term) {
            // If no _bannerExp, return just the _banner
            if (!term._bannerExp || !term._bannerExp.length) {
                if (term._banner) {
                    // Process special formatting but keep the text in black
                    // No warning symbol, keeping it minimal
                    return {
                        text: processPlainText(term._banner),
                        tooltip: 'No expansion available',
                        isExpanded: false,
                        matchesSearch: false
                    };
                }
                return { text: '', tooltip: '', isExpanded: false, matchesSearch: false };
            }

            // Extract all 'Right' values from _bannerExp
            const rightValues = term._bannerExp
                .filter(item => item.Right)
                .map(item => item.Right);

            // If there are Right values, use them
            if (rightValues.length > 0) {
                // Convert SLP1 to Devanagari for each Right value and check for matches
                let matchesSearch = false;
                const convertedValues = rightValues.map(value => {
                    try {
                        // Check if the value looks like Sanskrit (contains SLP1 characters)
                        // This regex checks for common SLP1 characters that indicate Sanskrit
                        if (/[AIUFXEOMNHSZR]|[kKgGNcCjJYwWqQRtTdDnpPbBmyrlvSzshL]/.test(value)) {
                            const devanagari = Sanscript.t(value, 'slp1', 'devanagari');

                            // Check if this matches the searched word
                            if (searchedWord && devanagari === searchedWord) {
                                matchesSearch = true;
                                console.log(`Found match for '${searchedWord}' in term:`, term);
                            }

                            return `<span class="devanagari">${devanagari}</span>`;
                        } else {
                            // Check if this matches the searched word (for non-Sanskrit)
                            if (searchedWord && value === searchedWord) {
                                matchesSearch = true;
                                console.log(`Found match for '${searchedWord}' in term:`, term);
                            }
                            return value; // Not Sanskrit, return as is
                        }
                    } catch (e) {
                        return value; // If conversion fails, return original
                    }
                });

                return {
                    text: convertedValues.join(', '),
                    tooltip: term._banner ? `${processPlainText(term._banner)}` : '',
                    isExpanded: true,
                    matchesSearch: matchesSearch
                };
            }

            // If all are Left values, use just the _banner
            if (term._banner) {
                // Process special formatting but keep the text in black
                // No warning symbol, keeping it minimal
                return {
                    text: processPlainText(term._banner),
                    tooltip: 'Couldn\'t expand',
                    isExpanded: false,
                    matchesSearch: false
                };
            }

            // Fallback
            return { text: '', tooltip: '', isExpanded: false, matchesSearch: false };
        }

        // Function to process a term's basic content (banner, grammar, meanings)
        function processTermContent(term) {
            let content = '';
            let matchesSearch = false;

            // Process banner/bannerExp
            const bannerInfo = processBannerExp(term);
            if (bannerInfo.text) {
                content += `<span class="banner" data-tooltip="${bannerInfo.tooltip}">${bannerInfo.text}</span>`;
                matchesSearch = bannerInfo.matchesSearch;
            }

            // Grammar info
            if (term._gram && term._gram.length) {
                content += `<span class="gram">${term._gram.map(processSpecialText).join(' ')}</span>`;
            }

            // Meanings
            if (term._meanings && term._meanings.length) {
                term._meanings.forEach(meaning => {
                    content += `<span class="meaning">${processMeaning(processSpecialText(meaning))}</span>`;
                });
            }

            return { content, matchesSearch };
        }

        // Recursive function to process morphisms at any nesting level
        function processMorphisms(morphisms, nestingLevel = 0) {
            if (!morphisms || !morphisms.length) return { html: '', hasMatch: false };

            let result = '';
            let hasMatch = false;

            morphisms.forEach(morphism => {
                const { content: morphismContent, matchesSearch } = processTermContent(morphism);
                let nestedContent = '';
                let nestedHasMatch = false;

                // Process nested morphisms recursively
                if (morphism._morphisms && morphism._morphisms.length) {
                    const nestedMorphisms = processMorphisms(morphism._morphisms, nestingLevel + 1);
                    nestedContent += nestedMorphisms.html;
                    if (nestedMorphisms.hasMatch) nestedHasMatch = true;
                }

                // Process nested samasas if any
                if (morphism._samasas && morphism._samasas.length) {
                    const nestedSamasas = processSamasas(morphism._samasas, nestingLevel + 1);
                    nestedContent += nestedSamasas.html;
                    if (nestedSamasas.hasMatch) nestedHasMatch = true;
                }

                // Add the morphism content to the result if not empty
                if (morphismContent || nestedContent) {
                    // Get ancestry info if available
                    let ancestryInfo = '';
                    if (morphism._ancestry && morphism._ancestry.length) {
                        ancestryInfo = morphism._ancestry.join(' / ');
                    }

                    // Determine if this morphism or any of its children match the search
                    const thisMatchesSearch = matchesSearch || nestedHasMatch;
                    if (thisMatchesSearch) hasMatch = true;

                    // Add appropriate classes based on search match
                    const searchMatchClass = thisMatchesSearch ? ' search-match' : '';

                    // Add nesting level as a data attribute for potential styling
                    result += `<span class="nested-term nested-morphism${searchMatchClass}" data-type="Morphism" data-nesting-level="${nestingLevel}" data-ancestry="${ancestryInfo}">${morphismContent}${nestedContent}</span>`;
                }
            });

            return { html: result, hasMatch };
        }

        // Recursive function to process samasas at any nesting level
        function processSamasas(samasas, nestingLevel = 0) {
            if (!samasas || !samasas.length) return { html: '', hasMatch: false };

            let result = '';
            let hasMatch = false;

            samasas.forEach(samasa => {
                const { content: samasaContent, matchesSearch } = processTermContent(samasa);
                let nestedContent = '';
                let nestedHasMatch = false;

                // Process nested samasas recursively
                if (samasa._samasas && samasa._samasas.length) {
                    const nestedSamasas = processSamasas(samasa._samasas, nestingLevel + 1);
                    nestedContent += nestedSamasas.html;
                    if (nestedSamasas.hasMatch) nestedHasMatch = true;
                }

                // Process nested morphisms if any
                if (samasa._morphisms && samasa._morphisms.length) {
                    const nestedMorphisms = processMorphisms(samasa._morphisms, nestingLevel + 1);
                    nestedContent += nestedMorphisms.html;
                    if (nestedMorphisms.hasMatch) nestedHasMatch = true;
                }

                // Add the samasa content to the result if not empty
                if (samasaContent || nestedContent) {
                    // Get ancestry info if available
                    let ancestryInfo = '';
                    if (samasa._ancestry && samasa._ancestry.length) {
                        ancestryInfo = samasa._ancestry.join(' / ');
                    }

                    // Determine if this samasa or any of its children match the search
                    const thisMatchesSearch = matchesSearch || nestedHasMatch;
                    if (thisMatchesSearch) hasMatch = true;

                    // Add appropriate classes based on search match
                    const searchMatchClass = thisMatchesSearch ? ' search-match' : '';

                    // Add nesting level as a data attribute for potential styling
                    result += `<span class="nested-term nested-samasa${searchMatchClass}" data-type="Samasa" data-nesting-level="${nestingLevel}" data-ancestry="${ancestryInfo}">${samasaContent}${nestedContent}</span>`;
                }
            });

            return { html: result, hasMatch };
        }

        // Function to flatten a term and all its nested terms into a single row
        function flattenTerm(term) {
            let result = '';
            let hasMatch = false;

            // Line number and page link removed

            // Process the term's own content
            const { content: termContent, matchesSearch } = processTermContent(term);
            result += termContent;
            if (matchesSearch) hasMatch = true;

            // Process morphisms with recursive handling for any nesting level
            if (term._morphisms && term._morphisms.length) {
                const morphismsResult = processMorphisms(term._morphisms);
                result += morphismsResult.html;
                if (morphismsResult.hasMatch) hasMatch = true;
            }

            // Process samasas with recursive handling for any nesting level
            if (term._samasas && term._samasas.length) {
                const samasasResult = processSamasas(term._samasas);
                result += samasasResult.html;
                if (samasasResult.hasMatch) hasMatch = true;
            }

            return { content: result, hasMatch };
        }

        // Function to render a term row
        function renderTermRow(term) {
            const { content: rowContent, hasMatch } = flattenTerm(term);
            const matchClass = hasMatch ? ' has-match' : '';
            return `<div class="term-row${matchClass}">${rowContent}</div>`;
        }

        // Function to render the current page of terms
        function renderCurrentPage() {
            const termsContainer = document.getElementById('terms-container');
            termsContainer.innerHTML = '';

            const startIndex = currentPage * PAGE_SIZE;
            const endIndex = Math.min(startIndex + PAGE_SIZE, termsData.length);

            for (let i = startIndex; i < endIndex; i++) {
                termsContainer.innerHTML += renderTermRow(termsData[i]);
            }

            // Update pagination info
            if (currentTermId) {
                document.getElementById('pagination-info').textContent = `Term ID: ${currentTermId}`;
                // Show keyboard navigation hint
                document.getElementById('keyboard-hint-top').style.display = 'block';
                document.getElementById('keyboard-hint-bottom').style.display = 'block';
            } else {
                document.getElementById('pagination-info').textContent =
                    `Page ${currentPage + 1} of ${Math.ceil(termsData.length / PAGE_SIZE)} (${startIndex + 1}-${endIndex} of ${termsData.length})`;
                // Hide keyboard navigation hints
                document.getElementById('keyboard-hint-top').style.display = 'none';
                document.getElementById('keyboard-hint-bottom').style.display = 'none';
            }

            // Update button states
            updateButtonStates();
        }

        // Function to update button states based on current context
        function updateButtonStates() {
            if (currentTermId) {
                // We're viewing a specific term, so prev/next navigate between terms
                document.getElementById('prev-page').disabled = currentTermId <= 1;
                document.getElementById('next-page').disabled = false; // Always allow going to next term
            } else {
                // We're viewing a regular page of terms (e.g., from es.json)
                const startIndex = currentPage * PAGE_SIZE;
                const endIndex = Math.min(startIndex + PAGE_SIZE, termsData.length);
                document.getElementById('prev-page').disabled = currentPage === 0;
                document.getElementById('next-page').disabled = endIndex >= termsData.length;
            }
        }

        // Function to load pagemarks data
        async function loadPagemarks() {
            try {
                const response = await fetch('/pagemarks-data.json');
                if (!response.ok) {
                    throw new Error(`HTTP error! Status: ${response.status}`);
                }
                const data = await response.json();
                pagemarks = data.pagemarks;
                sortedPagemarkKeys = data.sortedKeys;
                console.log(`Pagemarks loaded successfully with ${sortedPagemarkKeys.length} sorted keys`);
                return pagemarks;
            } catch (error) {
                console.error('Error loading pagemarks:', error);
                return {};
            }
        }

        // Function to get page info for a line number using binary search
        function getPageInfo(lineNumber) {
            // Convert lineNumber to a number if it's a string
            lineNumber = parseInt(lineNumber, 10);

            // If no sorted keys are available, return null
            if (!sortedPagemarkKeys || sortedPagemarkKeys.length === 0) {
                return null;
            }

            // Binary search to find the largest key less than or equal to lineNumber
            let left = 0;
            let right = sortedPagemarkKeys.length - 1;
            let result = -1;

            while (left <= right) {
                const mid = Math.floor((left + right) / 2);
                const midKey = sortedPagemarkKeys[mid];

                if (midKey <= lineNumber) {
                    // This key is a candidate, but we need to find the largest such key
                    result = mid;
                    left = mid + 1;
                } else {
                    // This key is too large
                    right = mid - 1;
                }
            }

            // If we found a valid key, extract the page number and create the URL
            if (result !== -1) {
                const maxKey = sortedPagemarkKeys[result];
                const pageMarkValue = pagemarks[maxKey];

                // Extract the page number from the format [Page????-?]...
                const match = pageMarkValue.match(/\[Page([^\]]+)\]/);
                if (match && match[1]) {
                    const pagePart = match[1].split('-')[0].trim();
                    return {
                        url: PAGE_URL_BASE + pagePart,
                        pageNumber: pagePart
                    };
                }
            }

            return null; // Return null if no valid page info could be determined
        }

        // Function to load a single term
        // Make it globally accessible
        window.loadSingleTerm = async function(termId) {
            try {
                // Check if term is already loaded
                if (loadedTermIds.has(termId)) {
                    return loadedTerms[termId];
                }

                // Log 5: Request for term-id file sent
                console.log(`5. Request for term-id file sent: /${termId}.json`);

                const response = await fetch(`/${termId}.json`);

                if (!response.ok) {
                    // If we get a 404, it might be a gap in the term numbering
                    if (response.status === 404) {
                        console.warn(`Term ${termId} not found, treating as empty`);
                        // Create a placeholder term
                        const placeholderTerm = {
                            __placeholder: true,
                            __termId: termId,
                            _banner: `Term ${termId} not available`
                        };

                        // Store in loaded terms
                        loadedTerms[termId] = [placeholderTerm];
                        loadedTermIds.add(termId);

                        return [placeholderTerm];
                    } else {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                }

                const termData = await response.json();

                // Log 6: Term-id received
                console.log(`6. Term-id received: ${termId}`);

                // Store in loaded terms
                loadedTerms[termId] = termData;
                loadedTermIds.add(termId);

                return termData;
            } catch (error) {
                console.error(`Error loading term ${termId}:`, error);
                return null;
            }
        }

        // Function to reset scroll and loading states
        function resetScrollStates() {
            // Reset all scroll and loading related variables
            scrollTimeout = null;
            lastBottomTermId = null;
            lastTopTermId = null;
            isLoadingTop = false;
            isLoadingBottom = false;

            // Debug mode constant (should match the one in handleScroll)
            const DEBUG_MODE = false;

            // Clear any existing debug info
            const debugEl = document.getElementById('scroll-debug');
            if (debugEl) {
                // Remove debug element
                debugEl.remove();
            }
        }

        // Function to load a term and its context (n-10 to n+10)
        // Returns a Promise that resolves when loading is complete
        async function loadTermWithContext(termId) {
            return new Promise(async (resolve, reject) => {
                try {
                    isLoading = true;

                    // Reset scroll states at the beginning of loading a new term
                    resetScrollStates();

                    // First load pagemarks if not already loaded
                    if (Object.keys(pagemarks).length === 0) {
                        await loadPagemarks();
                    }

                    // Set current term ID and requested term ID
                    currentTermId = termId;
                    requestedTermId = termId; // This is the term the user specifically requested

                    // Calculate the range of terms to load
                    const startTermId = termId; // Start from the current term (no terms before)
                    const endTermId = termId + WINDOW_AFTER; // Load 15 terms after

                    // Show loading message
                    document.getElementById('error').style.display = 'none';
                    document.getElementById('loading').style.display = 'block';
                    document.getElementById('loading').innerHTML = `
                        <div style="display: inline-block; animation: spin 1s linear infinite; font-size: 24px; margin-right: 10px;">⟳</div>
                        <span>Loading dictionary...</span>
                    `;

                    // Set a safety timeout to ensure the loading message doesn't get stuck
                    const loadingTimeout = setTimeout(() => {
                        console.warn('Safety timeout reached for term loading, clearing loading message');
                        document.getElementById('loading').style.display = 'none';
                    }, 10000); // 10 second timeout

                    // Load all terms in the range
                    const loadPromises = [];
                    for (let id = startTermId; id <= endTermId; id++) {
                        loadPromises.push(loadSingleTerm(id));
                    }

                    await Promise.all(loadPromises);

                    // Clear the safety timeout
                    clearTimeout(loadingTimeout);

                    // Hide loading message
                    document.getElementById('loading').style.display = 'none';

                    // Render the terms
                    renderTermsInRange(startTermId, endTermId);

                    // Log 7: Term was rendered
                    console.log(`7. Term was rendered: ${termId}`);

                    // Update pagination info - don't show term IDs to the user
                    document.getElementById('pagination-info').textContent = `Dictionary entry`;

                    // Show keyboard navigation hints
                    document.getElementById('keyboard-hint-top').style.display = 'block';
                    document.getElementById('keyboard-hint-bottom').style.display = 'block';

                    // Update button states
                    updateButtonStates();

                    // Add scroll event listener if not already added
                    if (!window.hasScrollListener) {
                        window.addEventListener('scroll', handleScroll);
                        window.hasScrollListener = true;

                        // Helper function to load more terms above when at the top
                        function loadMoreTermsAbove() {
                            if (lowestLoadedId <= 1 || isLoadingTop) {
                                return;
                            }

                            // Trigger loading of previous terms
                            const prevTermId = lowestLoadedId - 1;
                            const batchStartId = Math.max(1, prevTermId - BATCH_SIZE + 1);

                            // Show loading indicator
                            document.getElementById('loading-top').style.display = 'block';
                            isLoadingTop = true;

                            // Reset lastTopTermId to allow loading
                            lastTopTermId = null;

                            // Load each term in the batch
                            const loadPromises = [];
                            for (let id = prevTermId; id >= batchStartId; id--) {
                                loadPromises.push(loadMoreTerms(id, 'above'));
                            }

                            // Hide loading indicator when all terms are loaded
                            Promise.all(loadPromises).finally(() => {
                                setTimeout(() => {
                                    document.getElementById('loading-top').style.display = 'none';
                                    isLoadingTop = false;
                                }, 300);
                            });
                        }

                        // Local wheel event listener removed - using global wheel event listener instead

                        // Local keyboard event listener removed - using global keyboard event listener instead
                    }

                    isLoading = false;
                    resolve();
                } catch (error) {
                    console.error('Error loading terms:', error);

                    // Make sure to clear any loading timeouts
                    if (typeof loadingTimeout !== 'undefined') {
                        clearTimeout(loadingTimeout);
                    }

                    // Hide loading message and show error
                    document.getElementById('loading').style.display = 'none';
                    document.getElementById('error').style.display = 'block';
                    document.getElementById('error').textContent = `Error loading terms: ${error.message}`;
                    document.getElementById('keyboard-hint').style.display = 'none';
                    isLoading = false;
                    reject(error);
                }
        });
        }

        // Function to render terms in a specific range
        function renderTermsInRange(startTermId, endTermId) {
            const termsContainer = document.getElementById('terms-container');
            termsContainer.innerHTML = '';

            for (let id = startTermId; id <= endTermId; id++) {
                if (loadedTermIds.has(id)) {
                    const termData = loadedTerms[id];

                    // Create a container for this term
                    const termContainer = document.createElement('div');
                    termContainer.className = 'term-container';
                    termContainer.dataset.termId = id;

                    // Add highlighting class if this is the requested term
                    if (id === requestedTermId) {
                        termContainer.classList.add('highlighted');
                    }

                    // Check if it's a placeholder
                    if (termData[0].__placeholder) {
                        termContainer.innerHTML = `<div class="term-row"><em>Term ${id} not available</em></div>`;
                    } else {
                        // Render the term
                        termContainer.innerHTML = termData.map(term => renderTermRow(term)).join('');
                    }

                    termsContainer.appendChild(termContainer);
                }
            }

            // Scroll to the most granular highlighted element after a short delay
            // to ensure all DOM updates are complete
            setTimeout(() => {
                scrollToHighlightedElement(currentTermId);
            }, 50);
        }

        // Function to load the JSON data (for backward compatibility)
        async function loadTermsData(jsonPath) {
            try {
                isLoading = true;

                // First load pagemarks
                await loadPagemarks();

                // Check if there's a word parameter in the URL
                const wordParam = getUrlParameter('word');
                if (wordParam) {
                    // If there's a word parameter, look it up
                    await lookupDevanagariWord(wordParam);
                    return;
                }

                // Check if there's a path parameter in the URL
                const pathParam = getUrlParameter('path');
                if (pathParam) {
                    // Extract term ID from path if it's a numeric path
                    const termIdMatch = pathParam.match(/\/([0-9]+)\.json$/);
                    if (termIdMatch) {
                        // If it's a term ID, use the new loading method
                        const termId = parseInt(termIdMatch[1], 10);

                        // Update URL to remove the path parameter
                        const newUrl = new URL(window.location.href);
                        // Clear any existing parameters
                        Array.from(newUrl.searchParams.keys()).forEach(key => {
                            newUrl.searchParams.delete(key);
                        });
                        // Store the term ID in a hidden state for internal use
                        window.currentTermState = { termId: termId };
                        window.history.replaceState(window.currentTermState, '', newUrl.toString());

                        await loadTermWithContext(termId);
                        return;
                    }
                }

                // Use the provided path or default
                const path = jsonPath || '/es.json';

                // Extract term ID from path if it's a numeric path
                const termIdMatch = path.match(/\/([0-9]+)\.json$/);
                if (termIdMatch) {
                    // If it's a term ID, use the new loading method
                    const termId = parseInt(termIdMatch[1], 10);
                    await loadTermWithContext(termId);
                    return;
                } else {
                    // For non-term paths (e.g., es.json), use the old method
                    currentTermId = null;
                }

                let response;
                try {
                    response = await fetch(path);
                } catch (e) {
                    console.error('Error fetching from path:', path, e);
                    throw new Error(`Could not fetch from ${path}: ${e.message}`);
                }

                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }

                termsData = await response.json();

                // Hide loading message
                document.getElementById('loading').style.display = 'none';

                // Hide keyboard hint
                document.getElementById('keyboard-hint').style.display = 'none';

                // Render the first page
                renderCurrentPage();

                isLoading = false;
            } catch (error) {
                console.error('Error loading terms data:', error);
                document.getElementById('loading').style.display = 'none';
                document.getElementById('error').style.display = 'block';
                document.getElementById('error').textContent = `Error loading data: ${error.message}`;
                document.getElementById('keyboard-hint').style.display = 'none';
                isLoading = false;
            }
        }

        // Event listeners for pagination
        document.getElementById('prev-page').addEventListener('click', () => {
            if (currentTermId) {
                // We're viewing a specific term, so go to the previous term
                if (currentTermId > 1 && !isLoading) {
                    navigateToTerm(currentTermId - 1);
                }
            } else if (currentPage > 0) {
                // Regular pagination within a page of terms
                currentPage--;
                renderCurrentPage();
                window.scrollTo(0, 0);
            }
        });

        document.getElementById('next-page').addEventListener('click', () => {
            if (currentTermId) {
                // We're viewing a specific term, so go to the next term
                if (!isLoading) {
                    navigateToTerm(currentTermId + 1);
                }
            } else if ((currentPage + 1) * PAGE_SIZE < termsData.length) {
                // Regular pagination within a page of terms
                currentPage++;
                renderCurrentPage();
                window.scrollTo(0, 0);
            }
        });

        // Function to scroll to the most granular highlighted element
        function scrollToHighlightedElement(termId) {
            // Cancel any existing scroll timeout to prevent conflicts
            if (scrollTimeout) {
                clearTimeout(scrollTimeout);
                scrollTimeout = null;
            }

            // Wait a short time to ensure the DOM is fully updated
            setTimeout(() => {
                const termElement = document.querySelector(`.term-container[data-term-id="${termId}"]`);
                if (!termElement) {
                    return;
                }

                // Simply scroll to the top of the page
                window.scrollTo({
                    top: 0,
                    behavior: 'auto'
                });

                // In case top=0 already and hence handleScroll didn't trigger
                if(!window.termViewerState.lowestLoadedId)
                    window.termViewerState.lowestLoadedId = termId;
            }, 100); // Wait for DOM updates to complete
        }

        // Function to navigate to a specific term
        // Returns a Promise that resolves when navigation is complete
        function navigateToTerm(termId) {
            return new Promise((resolve, reject) => {
                if (isLoading) return resolve();

                // Parse termId as integer
                termId = parseInt(termId, 10);
                if (isNaN(termId) || termId <= 0) {
                    alert('Please enter a valid Term ID');
                    return resolve();
                }

                // Reset scroll states to prevent incorrect scrolling
                resetScrollStates();

                // Force scroll to top to reset view
                window.scrollTo(0, 0);

                // Clear any previous errors
                document.getElementById('error').style.display = 'none';
                document.getElementById('loading').style.display = 'block';
                document.getElementById('loading').innerHTML = `
                <div style="display: inline-block; animation: spin 1s linear infinite; font-size: 16px; margin-right: 5px;">⟳</div>
                <span>Loading...</span>
            `;

                // Set a safety timeout to ensure the loading message doesn't get stuck
                const navTimeout = setTimeout(() => {
                    console.warn('Safety timeout reached for term navigation, clearing loading message');
                    document.getElementById('loading').style.display = 'none';
                }, 10000); // 10 second timeout

                // Update URL without reloading the page, but don't expose term IDs
                // Instead, use a more user-friendly URL format
                const newUrl = new URL(window.location.href);
                // Clear any existing parameters
                Array.from(newUrl.searchParams.keys()).forEach(key => {
                    newUrl.searchParams.delete(key);
                });
                // Store the term ID in a hidden state for internal use
                window.currentTermState = { termId: termId };
                window.history.pushState(window.currentTermState, '', newUrl.toString());

                // Load the term and its context
                loadTermWithContext(termId).then(() => {
                    // Clear the navigation timeout when loading completes
                    clearTimeout(navTimeout);
                    resolve();
                }).catch(error => {
                    // Clear the navigation timeout when loading fails
                    clearTimeout(navTimeout);
                    reject(error);
                });
            });
        }

        // No file input handling needed

        // Default path for the JSON file
        const DEFAULT_JSON_PATH = '/es.json'; // When using the server, this will be served from apteDir.nosync/output/es.json

        // Function to get URL parameters
        function getUrlParameter(name) {
            name = name.replace(/[\[]/, '\\[').replace(/[\]]/, '\\]');
            const regex = new RegExp('[\\?&]' + name + '=([^&#]*)');
            const results = regex.exec(location.search);
            return results === null ? '' : decodeURIComponent(results[1].replace(/\+/g, ' '));
        }

        // No default path button anymore

        // Devanagari dependent vowel marks to independent vowels mapping
        const VOWEL_MARKS_TO_VOWELS = {
            '\u093e': '\u0906', // ा -> आ
            '\u093f': '\u0907', // ि -> इ
            '\u0940': '\u0908', // ी -> ई
            '\u0941': '\u0909', // ु -> उ
            '\u0942': '\u090a', // ू -> ऊ
            '\u0943': '\u090b', // ृ -> ऋ
            '\u0944': '\u0960', // ॄ -> ॠ
            '\u0962': '\u090c', // ॢ -> ऌ
            '\u0963': '\u0961', // ॣ -> ॡ
            '\u0945': '\u090f', // ॅ -> ए
            '\u0947': '\u090f', // े -> ए
            '\u0948': '\u0910', // ै -> ऐ
            '\u0949': '\u0913', // ॉ -> ओ
            '\u094b': '\u0913', // ो -> ओ
            '\u094c': '\u0914'  // ौ -> औ
        };

        // Function to convert Devanagari to intermediate form
        function devanagariToIntermediate(text) {
            // Result buffer
            let result = '';

            // Process each character
            for (let i = 0; i < text.length; i++) {
                const char = text[i];

                // Check if it's a dependent vowel mark
                if (VOWEL_MARKS_TO_VOWELS[char]) {
                    // Convert to independent vowel
                    result += VOWEL_MARKS_TO_VOWELS[char];
                }
                // Check if it's a virama (्)
                else if (char === '\u094d') {
                    // Skip the virama - we don't include it in the intermediate form
                    continue;
                }
                // For all other characters, just add them as is
                else {
                    result += char;
                    const consonants = "कखगघङचछजझञटठडढणतथदधनपफबभमयरलवशषसहळ";
                    if (consonants.includes(char)) {
                        if(i+1 == text.length)
                            result += 'अ';
                        else if(!VOWEL_MARKS_TO_VOWELS[text[i+1]] && text[i+1] != '\u094d')
                            result += 'अ';
                    }
                }
            }

            return result;
        }

        // Function to lookup a word in table_new.txt
        // Returns a Promise that resolves when the lookup is complete
        async function lookupDevanagariWord(word) {
            return new Promise(async (resolve, reject) => {
                if (isLoading) return resolve();

                if (!word) {
                    alert('Please enter a word');
                    return resolve();
                }

                // Reset scroll states to prevent incorrect scrolling
                resetScrollStates();

                // Force scroll to top to reset view
                window.scrollTo(0, 0);

                // Clean up sliding window and related bookkeeping variables
                // Clear the terms container
                const termsContainer = document.getElementById('terms-container');
                termsContainer.innerHTML = '';

                // Reset the loadedTermIds set
                loadedTermIds.clear();

                // Reset the loadedTerms object
                loadedTerms = {};

                // Reset window state variables
                currentTermId = null;
                requestedTermId = null;
                window.termViewerState.lowestLoadedId = null;
                window.termViewerState.lastTopTermId = null;
                window.termViewerState.isLoadingTop = false;
                lastBottomTermId = null;
                isLoadingBottom = false;

                // Store the searched word for highlighting nested elements
                searchedWord = word.trim();

                // Show loading message
                document.getElementById('error').style.display = 'none';
                document.getElementById('loading').style.display = 'block';
                document.getElementById('loading').innerHTML = `
                <div style="display: inline-block; animation: spin 1s linear infinite; font-size: 16px; margin-right: 5px;">⟳</div>
                <span>Looking up "${word}"...</span>
            `;

                // Set a safety timeout to ensure the loading message doesn't get stuck
                const safetyTimeout = setTimeout(() => {
                    console.warn('Safety timeout reached for word lookup, clearing loading message');
                    document.getElementById('loading').style.display = 'none';
                }, 5000); // 5 second timeout

                try {
                    // Fetch table_new.txt
                    // Log 2: Request sent for table_new
                    console.log('2. Request sent for table_new.txt');

                    const response = await fetch('/table_new.txt');
                    if (!response.ok) {
                        clearTimeout(safetyTimeout);
                        throw new Error(`Failed to load table_new.txt: ${response.status} ${response.statusText}`);
                    }

                    // Log 3: table_new received
                    console.log('3. table_new.txt received');

                    const text = await response.text();
                    const lines = text.split('\n');

                    // Convert Devanagari to intermediate form
                    let lookupKey = word.trim();
                    let intermediateForm = devanagariToIntermediate(lookupKey);
                    console.log(`Converted Devanagari "${lookupKey}" to intermediate form: "${intermediateForm}"`);

                    // Use the intermediate form for lookup
                    lookupKey = intermediateForm;

                    // Search for the word in table_new.txt
                    let termId = null;
                    let intermediateFormFound = false;

                    for (const line of lines) {
                        if (!line.trim()) continue;

                        const parts = line.split(':').map(part => part.trim());
                        if (parts.length >= 2 && parts[0] === lookupKey) {
                            // Found a match, extract the term ID (second field)
                            const id = parseInt(parts[1], 10);
                            if (!isNaN(id)) {
                                termId = id;
                                intermediateFormFound = true;
                                // Log 4: Term ID found
                                console.log('4. Term ID found:', id);
                                break;
                            }
                        }
                    }


                    if (termId) {
                        // Clear the safety timeout since we're navigating to the term
                        clearTimeout(safetyTimeout);

                        // Update URL to show the word being looked up
                        const newUrl = new URL(window.location.href);
                        // Clear any existing parameters
                        Array.from(newUrl.searchParams.keys()).forEach(key => {
                            newUrl.searchParams.delete(key);
                        });
                        // Add the word as a parameter
                        newUrl.searchParams.set('word', word.trim());
                        window.history.pushState({word: word.trim(), termId: termId}, '', newUrl.toString());

                        // Navigate to the term
                        navigateToTerm(termId).finally(() => {
                            resolve();
                        });
                    } else {
                        // Word not found
                        clearTimeout(safetyTimeout);
                        document.getElementById('loading').style.display = 'none';

                        // Show error message
                        let errorMessage = `Word "${word}" not found in dictionary.`;

                        document.getElementById('error').style.display = 'block';
                        document.getElementById('error').innerHTML = errorMessage;
                        document.getElementById('keyboard-hint-top').style.display = 'none';
                        document.getElementById('keyboard-hint-bottom').style.display = 'none';
                        resolve();
                    }
                } catch (error) {
                    clearTimeout(safetyTimeout);
                    console.error('Error looking up word:', error);
                    document.getElementById('loading').style.display = 'none';
                    document.getElementById('error').style.display = 'block';
                    document.getElementById('error').textContent = `Error looking up word: ${error.message}`;
                    document.getElementById('keyboard-hint-top').style.display = 'none';
                    document.getElementById('keyboard-hint-bottom').style.display = 'none';
                    reject(error);
                }
            });
        }

        // Term ID input feature has been removed

        // Event listener for the lookup Devanagari word button
        document.getElementById('lookup-devanagari').addEventListener('click', function() {
            const inputField = document.getElementById('devanagari-input');
            const word = inputField.value.trim();

            // Log 1: Input submitted by user
            console.log('1. Input submitted by user:', word);

            lookupDevanagariWord(word).catch(error => {
                console.error('Error in word lookup:', error);
            });
            // Defocus the input field to allow normal scrolling with arrow keys
            inputField.blur();
        });

        // Handle Enter key in the Devanagari input field
        document.getElementById('devanagari-input').addEventListener('keypress', function(event) {
            if (event.key === 'Enter') {
                event.preventDefault();
                // Get the word and look it up directly
                const word = this.value.trim();

                // Log 1: Input submitted by user
                console.log('1. Input submitted by user:', word);

                lookupDevanagariWord(word).catch(error => {
                    console.error('Error in word lookup:', error);
                });
                // Defocus (blur) the input field to allow normal scrolling with arrow keys
                this.blur();
            }
        });

        // Keyboard navigation has been removed as requested

        // Scroll event handler for infinite scrolling
        let scrollTimeout;
        let lastBottomTermId = null;
        let lastTopTermId = null;
        const BATCH_SIZE = 7; // Load half the WINDOW_AFTER size at once
        const SCROLL_TIMEOUT = 300; // Increased timeout for larger payloads
        let isLoadingTop = false; // Flag to track loading state for top indicator
        let isLoadingBottom = false; // Flag to track loading state for bottom indicator

        function handleScroll() {
            // Debug element code is now disabled
            // Set to true to enable
            const DEBUG_MODE = false;

            let debugEl = document.getElementById('scroll-debug');
            if (DEBUG_MODE) {
                if (!debugEl) {
                    debugEl = document.createElement('div');
                    debugEl.id = 'scroll-debug';
                    debugEl.style.position = 'fixed';
                    debugEl.style.bottom = '10px';
                    debugEl.style.right = '10px';
                    debugEl.style.backgroundColor = 'rgba(0,0,0,0.7)';
                    debugEl.style.color = 'white';
                    debugEl.style.padding = '10px';
                    debugEl.style.borderRadius = '5px';
                    debugEl.style.zIndex = '1000';
                    debugEl.style.fontSize = '12px';
                    document.body.appendChild(debugEl);
                }
            } else if (debugEl) {
                // Remove debug element if it exists and debug mode is off
                debugEl.remove();
                debugEl = null;
            }

            if (scrollTimeout || isLoading || !currentTermId) {
                if (DEBUG_MODE && debugEl) {
                    debugEl.innerHTML = `Waiting: timeout=${!!scrollTimeout}, loading=${isLoading}, currentTermId=${currentTermId}`;
                }
                return;
            }

            // Get viewport dimensions
            const scrollPosition = window.scrollY;
            const windowHeight = window.innerHeight;
            const documentHeight = document.documentElement.scrollHeight;

            // No need to adjust for header since it's now in the normal document flow
            const effectiveScrollPosition = scrollPosition;

            // Get all loaded term IDs in order
            const termContainers = document.querySelectorAll('.term-container');
            const loadedIds = Array.from(termContainers).map(container =>
                parseInt(container.dataset.termId, 10)).sort((a, b) => a - b);

            // Find the highest and lowest loaded term IDs
            const lowestLoadedId = loadedIds.length > 0 ? loadedIds[0] : currentTermId;
            const highestLoadedId = loadedIds.length > 0 ? loadedIds[loadedIds.length - 1] : currentTermId;

            // Update global state
            window.termViewerState.lowestLoadedId = lowestLoadedId;
            window.termViewerState.isLoadingTop = isLoadingTop;

            // Update debug display if debug mode is enabled
            if (DEBUG_MODE && debugEl) {
                debugEl.innerHTML = `Scroll: ${scrollPosition}px<br>
                    Effective Scroll: ${effectiveScrollPosition}px<br>
                    Window Height: ${windowHeight}px<br>
                    Document Height: ${documentHeight}px<br>
                    Lowest ID: ${lowestLoadedId}<br>
                    Highest ID: ${highestLoadedId}<br>
                    Current ID: ${currentTermId}<br>
                    Near Top: ${scrollPosition < 200}<br>
                    Near Bottom: ${scrollPosition + windowHeight > documentHeight - 500}`;
            }

            scrollTimeout = setTimeout(() => {
                // Update current term ID based on scroll position
                updateCurrentTermIdFromScroll();
                scrollTimeout = null;
            }, SCROLL_TIMEOUT);
        }

        // Function to load more terms in a specific direction
        // Make it globally accessible
        window.loadMoreTerms = async function(termId, direction) {
            if (isLoading || !termId || termId < 1) return Promise.resolve();

            // Check if this term is already loaded
            if (document.querySelector(`.term-container[data-term-id="${termId}"]`)) {
                console.log(`Term ${termId} is already in the DOM, skipping`);
                return Promise.resolve();
            }

            try {
                isLoading = true;

                // Load the term
                const termData = await loadSingleTerm(termId);

                if (termData) {
                    // Double-check that the term hasn't been added while we were loading
                    if (document.querySelector(`.term-container[data-term-id="${termId}"]`)) {
                        console.log(`Term ${termId} was added while loading, skipping`);
                        isLoading = false;
                        return;
                    }

                    // Get the terms container
                    const termsContainer = document.getElementById('terms-container');

                    // Create a container for this term
                    const termContainer = document.createElement('div');
                    termContainer.className = 'term-container';
                    termContainer.dataset.termId = termId;

                    // Add highlighting class if this is the requested term
                    if (termId === requestedTermId) {
                        termContainer.classList.add('highlighted');
                    }

                    // Check if it's a placeholder
                    if (termData[0].__placeholder) {
                        termContainer.innerHTML = `<div class="term-row"><em>Term ${termId} not available</em></div>`;
                    } else {
                        // Render the term
                        termContainer.innerHTML = termData.map(term => renderTermRow(term)).join('');
                    }

                    // Add to the DOM in the appropriate position
                    if (direction === 'above') {
                        // Save current scroll position and document height
                        const oldScrollY = window.scrollY;
                        const oldDocumentHeight = document.documentElement.scrollHeight;

                        // Add the new term at the top
                        termsContainer.insertBefore(termContainer, termsContainer.firstChild);
                        console.log(`Added term ${termId} at the top`);

                        // Wait for the DOM to update
                        setTimeout(() => {
                            // Calculate how much the document height changed
                            const newDocumentHeight = document.documentElement.scrollHeight;
                            const heightDifference = newDocumentHeight - oldDocumentHeight;

                            // Adjust scroll position to maintain the same view
                            if (heightDifference > 0) {
                                // Special case: if we were at the top (scrollY === 0), don't adjust scroll position
                                // This allows the user to see the newly loaded content at the top
                                if (oldScrollY === 0) {
                                    console.log('At top of page, not adjusting scroll position to show new content');
                                } else {
                                    // Otherwise, maintain the same view by adjusting scroll position
                                    window.scrollTo(0, oldScrollY + heightDifference);
                                    console.log(`Adjusted scroll position by ${heightDifference}px (from ${oldScrollY} to ${oldScrollY + heightDifference})`);
                                }
                            }
                        }, 0);
                    } else {
                        termsContainer.appendChild(termContainer);
                        console.log(`Added term ${termId} at the bottom`);
                    }

                    // Trim excess terms to maintain the window size
                    trimExcessTerms();
                }

                isLoading = false;
                return Promise.resolve();
            } catch (error) {
                console.error(`Error loading more terms:`, error);
                isLoading = false;
                return Promise.reject(error);
            }
        }

        // Function to trim excess terms to maintain the window size
        function trimExcessTerms() {
            const termContainers = document.querySelectorAll('.term-container');
            if (termContainers.length <= WINDOW_SIZE * 6) return; // Keep an even larger buffer (6x instead of 4x)

            // Get the current term element
            const currentTermElement = document.querySelector(`.term-container[data-term-id="${currentTermId}"]`);
            if (!currentTermElement) return;

            // Calculate which terms to keep - use a wider range than the normal window
            const termIds = Array.from(termContainers).map(container => parseInt(container.dataset.termId, 10));
            let minKeepId = Math.max(0, currentTermId - WINDOW_SIZE);
            let maxKeepId = currentTermId;
            if (termIds.length > 0 && currentTermId === termIds[0]) {
                minKeepId = currentTermId; // Start from the current term (no terms before)
                maxKeepId = currentTermId + WINDOW_AFTER * 2; // Double the keep range for terms after
            }

            // Remove terms that are too far from the current term
            for (const container of termContainers) {
                const termId = parseInt(container.dataset.termId, 10);
                if (termId < minKeepId || termId > maxKeepId) {
                    // Remove from DOM
                    container.remove();

                    // Also remove from loadedTermIds set to allow reloading if needed
                    loadedTermIds.delete(termId);

                    // Reset lastTopTermId and lastBottomTermId if they match the removed term
                    if (termId === lastTopTermId) {
                        lastTopTermId = null;
                    }
                    if (termId === lastBottomTermId) {
                        lastBottomTermId = null;
                    }

                    console.log(`Removed term ${termId} from DOM and tracking`);
                }
            }
        }

        // Function to update current term ID based on scroll position
        function updateCurrentTermIdFromScroll() {
            const termContainers = document.querySelectorAll('.term-container');
            if (!termContainers.length) return;

            // No need to get header height since it's in the normal document flow

            // Find the term closest to the center of the viewport
            const viewportMiddle = window.innerHeight / 2;
            let closestTerm = null;
            let closestDistance = Infinity;

            for (const container of termContainers) {
                const rect = container.getBoundingClientRect();
                const termMiddle = rect.top + rect.height / 2;
                const distance = Math.abs(termMiddle - viewportMiddle);

                if (distance < closestDistance) {
                    closestDistance = distance;
                    closestTerm = container;
                }
            }

            if (closestTerm) {
                const newTermId = parseInt(closestTerm.dataset.termId, 10);

                // Only update if it changed
                if (newTermId !== currentTermId) {
                    // Update current term ID
                    currentTermId = newTermId;

                    // Store the term ID in a hidden state for internal use
                    window.currentTermState = { termId: currentTermId };

                    // Update pagination info - don't show term IDs to the user
                    document.getElementById('pagination-info').textContent = `Dictionary entry`;

                    // Update button states
                    updateButtonStates();
                }
            }
        }

        // Make lowestLoadedId and lastTopTermId globally accessible
        window.termViewerState = {
            lowestLoadedId: null,
            lastTopTermId: null,
            isLoadingTop: false
        };

        // Global wheel event listener for top scrolling - DISABLED
        // We no longer load terms on mouse-based scroll events

        // Global keyboard event listener for arrow keys
        window.addEventListener('keydown', function(event) {
            // Handle up arrow key when at the top
            if (window.scrollY === 0 && (event.key === 'ArrowUp' || event.key === 'Up')) {
                // Check if we're in a term view context
                if (window.termViewerState.lowestLoadedId && window.termViewerState.lowestLoadedId > 1 && !window.termViewerState.isLoadingTop) {
                    // Force reset lastTopTermId to allow loading
                    window.termViewerState.lastTopTermId = null;

                    // Force loading of previous terms
                    // Check if the terms immediately before the lowest loaded term are already in the DOM
                    const lowestLoadedId = window.termViewerState.lowestLoadedId;
                    let prevTermId = lowestLoadedId - 1;

                    // If the previous terms are already loaded, go back further
                    while (prevTermId > 1 && document.querySelector(`.term-container[data-term-id="${prevTermId}"]`)) {
                        prevTermId--;
                    }

                    // Calculate batch start, ensuring we don't go below 1
                    const batchStartId = Math.max(1, prevTermId - 7 + 1); // Use BATCH_SIZE (7)

                    // Show loading indicator
                    document.getElementById('loading-top').style.display = 'block';
                    window.termViewerState.isLoadingTop = true;

                    // Load each term in the batch, but only if it's not already in the DOM
                    const loadPromises = [];
                    for (let id = prevTermId; id >= batchStartId; id--) {
                        // Skip terms that are already in the DOM
                        if (!document.querySelector(`.term-container[data-term-id="${id}"]`)) {
                            if (typeof window.loadMoreTerms === 'function') {
                                loadPromises.push(window.loadMoreTerms(id, 'above'));
                            }
                        }
                    }

                    // Hide loading indicator when all terms are loaded
                    if (loadPromises.length > 0) {
                        Promise.all(loadPromises).finally(() => {
                            setTimeout(() => {
                                document.getElementById('loading-top').style.display = 'none';
                                window.termViewerState.isLoadingTop = false;
                            }, 300);
                        });
                    } else {
                        // If no terms were loaded, hide the indicator
                        setTimeout(() => {
                            document.getElementById('loading-top').style.display = 'none';
                            window.termViewerState.isLoadingTop = false;
                        }, 300);
                    }
                }
            }

            // Handle down arrow key when at the bottom
            if ((window.innerHeight + window.scrollY >= document.body.offsetHeight - 5) &&
                (event.key === 'ArrowDown' || event.key === 'Down')) {
                // Check if we're in a term view context and not already loading
                const termContainers = document.querySelectorAll('.term-container');
                if (termContainers.length > 0 && !isLoadingBottom) {
                    // Get the highest loaded term ID
                    const loadedIds = Array.from(termContainers).map(container =>
                        parseInt(container.dataset.termId, 10)).sort((a, b) => a - b);
                    const highestLoadedId = loadedIds.length > 0 ? loadedIds[loadedIds.length - 1] : currentTermId;

                    // Force reset lastBottomTermId to allow loading
                    lastBottomTermId = null;

                    // Force loading of next terms
                    const nextTermId = highestLoadedId + 1;
                    const batchEndId = nextTermId + BATCH_SIZE - 1;

                    // Show loading indicator
                    document.getElementById('loading-bottom').style.display = 'block';
                    isLoadingBottom = true;

                    // Load each term in the batch
                    const loadPromises = [];
                    for (let id = nextTermId; id <= batchEndId; id++) {
                        // Skip terms that are already in the DOM
                        if (!document.querySelector(`.term-container[data-term-id="${id}"]`)) {
                            if (typeof window.loadMoreTerms === 'function') {
                                loadPromises.push(window.loadMoreTerms(id, 'below'));
                            }
                        }
                    }

                    // Hide loading indicator when all terms are loaded
                    if (loadPromises.length > 0) {
                        Promise.all(loadPromises).finally(() => {
                            setTimeout(() => {
                                document.getElementById('loading-bottom').style.display = 'none';
                                isLoadingBottom = false;
                            }, 300);
                        });
                    } else {
                        // If no terms were loaded, hide the indicator
                        setTimeout(() => {
                            document.getElementById('loading-bottom').style.display = 'none';
                            isLoadingBottom = false;
                        }, 300);
                    }
                }
            }
        });

        // Load data based on URL parameters
        document.addEventListener('DOMContentLoaded', function() {
            // Set header-spacer height to match the header height
            const headerHeight = document.getElementById('header').offsetHeight;
            document.getElementById('header-spacer').style.height = headerHeight + 'px';

            // Update header-spacer height on window resize
            window.addEventListener('resize', function() {
                const headerHeight = document.getElementById('header').offsetHeight;
                document.getElementById('header-spacer').style.height = headerHeight + 'px';
            });

            // Make sure loading indicators are hidden initially
            document.getElementById('loading-top').style.display = 'none';
            document.getElementById('loading-bottom').style.display = 'none';
            document.getElementById('keyboard-hint-top').style.display = 'none';
            document.getElementById('keyboard-hint-bottom').style.display = 'none';

            // Check if word parameter is provided in URL
            const wordParam = getUrlParameter('word');
            if (wordParam) {
                // If there's a word parameter, look it up
                lookupDevanagariWord(wordParam).catch(error => {
                    console.error('Error in word lookup:', error);
                });
                return;
            }

            // Check if path is provided in URL (for backward compatibility)
            const jsonPath = getUrlParameter('path');
            if (jsonPath) {
                loadTermsData(jsonPath);
            } else {
                // Hide loading message if no parameters are provided
                document.getElementById('loading').style.display = 'none';
                document.getElementById('keyboard-hint-top').style.display = 'none';
                document.getElementById('keyboard-hint-bottom').style.display = 'none';
            }
        });
    </script>
</body>
</html>
