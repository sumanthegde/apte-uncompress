<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Term Viewer</title>
    <script src="sanscript.js"></script>
    <style>
        body {
            font-family: 'Arial', sans-serif;
            line-height: 1.6;
            margin: 0;
            padding: 20px;
            background-color: #f5f5f5;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding-left: 40px; /* Make room for term IDs */
        }

        h1 {
            text-align: center;
            margin-bottom: 20px;
        }

        .term-row {
            background-color: white;
            border-radius: 4px;
            padding: 15px;
            margin-bottom: 10px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            overflow-wrap: break-word;
            word-wrap: break-word;
            hyphens: auto;
        }

        /* Line number styling removed */

        .ancestry {
            display: inline;
            color: #555;
            font-style: italic;
            margin-right: 10px;
        }

        .banner {
            display: inline;
            font-weight: bold;
            margin-right: 10px;
            position: relative;
            cursor: help;
        }

        /* Tooltip for banner */
        .banner::after {
            content: attr(data-tooltip);
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            background-color: #333;
            color: white;
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 0.8em;
            white-space: nowrap;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.2s, visibility 0.2s;
            z-index: 100;
        }

        .banner:hover::after {
            opacity: 1;
            visibility: visible;
        }

        .gram {
            display: inline;
            color: #0066cc;
            margin-right: 10px;
        }

        .meaning {
            display: inline;
            margin-right: 10px;
        }

        .meaning-number {
            font-weight: bold;
        }

        .special-text {
            color: #9c27b0;
            font-style: italic;
        }

        .devanagari {
            font-family: 'Noto Sans Devanagari', 'Sanskrit 2003', sans-serif;
            font-size: 1.1em;
            color: #9c27b0;
        }

        .warning-symbol {
            color: red;
            font-weight: bold;
        }

        .loading {
            text-align: center;
            padding: 20px;
            font-size: 1.2em;
        }

        .error {
            color: red;
            text-align: center;
            padding: 20px;
        }

        /* Nested term sections */
        .nested-term {
            display: inline;
            position: relative;
            border-radius: 3px;
            border: 1px solid transparent;
            padding: 1px 2px;
            margin: 0 1px;
            cursor: pointer;
        }

        /* Left border only for nested terms */
        .nested-morphism {
            border-color: transparent;
            border-left: 3px solid rgba(0, 100, 200, 0.3);
            background-color: transparent;
            padding-left: 4px;
        }

        .nested-samasa {
            border-color: transparent;
            border-left: 3px solid rgba(150, 0, 200, 0.3);
            background-color: transparent;
            padding-left: 4px;
        }

        /* Nested items with different nesting levels */
        /* Level 0 (first level) */
        .nested-morphism[data-nesting-level="0"] {
            border-left: 3px solid rgba(0, 100, 200, 0.3);
            margin-left: 2px;
        }

        .nested-samasa[data-nesting-level="0"] {
            border-left: 3px solid rgba(150, 0, 200, 0.3);
            margin-left: 2px;
        }

        /* Level 1 (second level) */
        .nested-morphism[data-nesting-level="1"] {
            border-left: 3px solid rgba(0, 100, 200, 0.5);
            margin-left: 2px;
        }

        .nested-samasa[data-nesting-level="1"] {
            border-left: 3px solid rgba(150, 0, 200, 0.5);
            margin-left: 2px;
        }

        /* Level 2 (third level) */
        .nested-morphism[data-nesting-level="2"] {
            border-left: 3px solid rgba(0, 100, 200, 0.7);
            margin-left: 2px;
        }

        .nested-samasa[data-nesting-level="2"] {
            border-left: 3px solid rgba(150, 0, 200, 0.7);
            margin-left: 2px;
        }

        /* Level 3+ (fourth level and beyond) */
        .nested-morphism[data-nesting-level="3"],
        .nested-morphism[data-nesting-level="4"] {
            border-left: 3px solid rgba(0, 100, 200, 0.9);
            margin-left: 2px;
        }

        .nested-samasa[data-nesting-level="3"],
        .nested-samasa[data-nesting-level="4"] {
            border-left: 3px solid rgba(150, 0, 200, 0.9);
            margin-left: 2px;
        }

        /* Cross-nested items (morphism in samasa or vice versa) */
        .nested-term .nested-term {
            margin-left: 2px;
        }

        /* Hover effect - slightly darker left border */
        .nested-morphism:hover {
            border-left-color: rgba(0, 100, 200, 0.8);
        }

        .nested-samasa:hover {
            border-left-color: rgba(150, 0, 200, 0.8);
        }

        /* Pagination */
        .pagination {
            display: flex;
            justify-content: center;
            margin: 20px 0;
        }

        .pagination button {
            background-color: #4CAF50;
            color: white;
            border: none;
            padding: 8px 16px;
            margin: 0 5px;
            cursor: pointer;
            border-radius: 4px;
        }

        .pagination button:disabled {
            background-color: #cccccc;
            cursor: not-allowed;
        }

        .pagination-info {
            margin: 0 15px;
            line-height: 32px;
        }

        /* Styling for infinite scroll */
        .term-container {
            margin-bottom: 20px;
            position: relative;
        }

        .term-container::before {
            content: attr(data-term-id);
            position: absolute;
            left: -40px;
            top: 15px;
            color: #999;
            font-size: 0.9em;
        }
    </style>
</head>
<body>
    <div class="container">
        <div id="header" style="position: fixed; top: 0; left: 0; right: 0; background-color: #f5f5f5; box-shadow: 0 2px 5px rgba(0,0,0,0.1); z-index: 100;">
            <div id="file-selector" style="text-align: center; padding: 15px;">
                <div style="display: flex; justify-content: center; align-items: center;">
                    <input type="number" id="term-id-input" placeholder="Enter Term ID (e.g., 9091)" style="padding: 8px; width: 250px; margin-right: 10px;">
                    <button id="load-term-id" style="background-color: #4CAF50; color: white; border: none; padding: 8px 16px; cursor: pointer; border-radius: 4px;">Load Term</button>
                </div>
            </div>
            <!-- Pagination removed as requested -->
            <div style="display: none;">
                <span id="pagination-info">Page 1</span>
                <button id="prev-page" disabled>Previous</button>
                <button id="next-page">Next</button>
            </div>
        </div>

        <!-- Spacer to push content below the fixed header -->
        <div id="header-spacer" style="height: 80px;"></div>

        <div id="loading" class="loading">Loading term data... Please wait.</div>
        <div id="error" class="error" style="display: none;"></div>

        <div id="terms-container"></div>

        <div id="keyboard-hint" style="text-align: center; margin-top: 10px; font-size: 0.9em; color: #666; display: none;">
            <span>Use ← and → arrow keys to navigate between terms</span>
        </div>
    </div>

    <script>
        // Configuration
        const PAGE_SIZE = 20;
        let currentPage = 0;
        let termsData = [];
        let pagemarks = {}; // Will store the pagemarks data
        let sortedPagemarkKeys = []; // Will store the sorted keys for binary search
        let currentTermId = null; // Current term ID being viewed
        let isLoading = false; // Flag to prevent multiple simultaneous loads

        // Infinite scroll configuration
        const WINDOW_SIZE = 21; // Current term + 10 before + 10 after
        const WINDOW_HALF = Math.floor(WINDOW_SIZE / 2); // 10 terms on each side
        let loadedTerms = {}; // Map of termId -> term data
        let loadedTermIds = new Set(); // Set of loaded term IDs

        // Base URL for page links
        const PAGE_URL_BASE = "https://www.sanskrit-lexicon.uni-koeln.de/scans/csl-apidev/servepdf.php?dict=AP90&page=";

        // Function to process special text formatting
        function processSpecialText(text) {
            if (!text) return '';

            // Convert SLP1 encoded Sanskrit text in {# #} brackets to Devanagari
            text = text.replace(/\{#(.*?)#\}/g, function(match, p1) {
                try {
                    // Convert SLP1 to Devanagari
                    const devanagari = Sanscript.t(p1, 'slp1', 'devanagari');
                    return `<span class="devanagari">${devanagari}</span>`;
                } catch (e) {
                    // If conversion fails, just return the original text with special styling
                    return `<span class="special-text">${p1}</span>`;
                }
            });

            // Remove {% %} brackets but style the content differently
            text = text.replace(/\{%(.*?)%\}/g, '<span class="special-text">$1</span>');

            // Remove <ab> </ab> tags but style the content differently
            text = text.replace(/<ab>(.*?)<\/ab>/g, '<span class="special-text">$1</span>');

            return text;
        }

        // Function to process special text formatting without special styling (for banner text)
        function processPlainText(text) {
            if (!text) return '';

            // Convert SLP1 encoded Sanskrit text in {# #} brackets to Devanagari
            text = text.replace(/\{#(.*?)#\}/g, function(match, p1) {
                try {
                    // Convert SLP1 to Devanagari
                    return Sanscript.t(p1, 'slp1', 'devanagari');
                } catch (e) {
                    // If conversion fails, just return the original text
                    return p1;
                }
            });

            // Remove {% %} brackets without special styling
            text = text.replace(/\{%(.*?)%\}/g, '$1');

            // Remove <ab> </ab> tags without special styling
            text = text.replace(/<ab>(.*?)<\/ab>/g, '$1');

            return text;
        }

        // Function to process meaning text with numbered meanings
        function processMeaning(text) {
            if (!text) return '';

            // Normalize all whitespace (including newlines) to a single space
            text = text.replace(/\s+/g, ' ');

            // Handle {@--n@} format at the beginning of meanings
            text = text.replace(/\{@--(\d+)@\}/g, '<span class="meaning-number">$1</span> ');

            // Handle {n} format at the beginning of meanings
            text = text.replace(/^\{(\d+)\}\s*/g, '<span class="meaning-number">$1</span> ');

            return text;
        }

        // Function to process banner expansion
        function processBannerExp(term) {
            // If no _bannerExp, return the _banner with warning symbol
            if (!term._bannerExp || !term._bannerExp.length) {
                if (term._banner) {
                    // Process special formatting but keep the text in black
                    // Add warning symbol since there's no _bannerExp
                    return {
                        text: processPlainText(term._banner) + ' <span class="warning-symbol">⚠️</span>',
                        tooltip: 'No expansion available',
                        isExpanded: false
                    };
                }
                return { text: '', tooltip: '', isExpanded: false };
            }

            // Extract all 'Right' values from _bannerExp
            const rightValues = term._bannerExp
                .filter(item => item.Right)
                .map(item => item.Right);

            // If there are Right values, use them
            if (rightValues.length > 0) {
                // Convert SLP1 to Devanagari for each Right value
                const convertedValues = rightValues.map(value => {
                    try {
                        // Check if the value looks like Sanskrit (contains SLP1 characters)
                        // This regex checks for common SLP1 characters that indicate Sanskrit
                        if (/[AIUFXEOMNHSZR]|[kKgGNcCjJYwWqQRtTdDnpPbBmyrlvSzshL]/.test(value)) {
                            return `<span class="devanagari">${Sanscript.t(value, 'slp1', 'devanagari')}</span>`;
                        } else {
                            return value; // Not Sanskrit, return as is
                        }
                    } catch (e) {
                        return value; // If conversion fails, return original
                    }
                });

                return {
                    text: convertedValues.join(', '),
                    //tooltip: term._banner ? `Originally: ${processPlainText(term._banner)}` : '',
                    tooltip: term._banner ? `${processPlainText(term._banner)}` : '',
                    isExpanded: true
                };
            }

            // If all are Left values, use _banner with warning symbol
            if (term._banner) {
                // Process special formatting but keep the text in black
                // Only the warning symbol is red
                return {
                    text: processPlainText(term._banner) + ' <span class="warning-symbol">⚠️</span>',
                    tooltip: 'Couldn\'t expand',
                    isExpanded: false
                };
            }

            // Fallback
            return { text: '', tooltip: '', isExpanded: false };
        }

        // Function to process a term's basic content (banner, grammar, meanings)
        function processTermContent(term) {
            let content = '';

            // Process banner/bannerExp
            const bannerInfo = processBannerExp(term);
            if (bannerInfo.text) {
                content += `<span class="banner" data-tooltip="${bannerInfo.tooltip}">${bannerInfo.text}</span>`;
            }

            // Grammar info
            if (term._gram && term._gram.length) {
                content += `<span class="gram">${term._gram.map(processSpecialText).join(' ')}</span>`;
            }

            // Meanings
            if (term._meanings && term._meanings.length) {
                term._meanings.forEach(meaning => {
                    content += `<span class="meaning">${processMeaning(processSpecialText(meaning))}</span>`;
                });
            }

            return content;
        }

        // Recursive function to process morphisms at any nesting level
        function processMorphisms(morphisms, nestingLevel = 0) {
            if (!morphisms || !morphisms.length) return '';

            let result = '';

            morphisms.forEach(morphism => {
                let morphismContent = processTermContent(morphism);

                // Process nested morphisms recursively
                if (morphism._morphisms && morphism._morphisms.length) {
                    morphismContent += processMorphisms(morphism._morphisms, nestingLevel + 1);
                }

                // Process nested samasas if any
                if (morphism._samasas && morphism._samasas.length) {
                    morphismContent += processSamasas(morphism._samasas, nestingLevel + 1);
                }

                // Add the morphism content to the result if not empty
                if (morphismContent) {
                    // Get ancestry info if available
                    let ancestryInfo = '';
                    if (morphism._ancestry && morphism._ancestry.length) {
                        ancestryInfo = morphism._ancestry.join(' / ');
                    }

                    // Add nesting level as a data attribute for potential styling
                    result += `<span class="nested-term nested-morphism" data-type="Morphism" data-nesting-level="${nestingLevel}" data-ancestry="${ancestryInfo}">${morphismContent}</span>`;
                }
            });

            return result;
        }

        // Recursive function to process samasas at any nesting level
        function processSamasas(samasas, nestingLevel = 0) {
            if (!samasas || !samasas.length) return '';

            let result = '';

            samasas.forEach(samasa => {
                let samasaContent = processTermContent(samasa);

                // Process nested samasas recursively
                if (samasa._samasas && samasa._samasas.length) {
                    samasaContent += processSamasas(samasa._samasas, nestingLevel + 1);
                }

                // Process nested morphisms if any
                if (samasa._morphisms && samasa._morphisms.length) {
                    samasaContent += processMorphisms(samasa._morphisms, nestingLevel + 1);
                }

                // Add the samasa content to the result if not empty
                if (samasaContent) {
                    // Get ancestry info if available
                    let ancestryInfo = '';
                    if (samasa._ancestry && samasa._ancestry.length) {
                        ancestryInfo = samasa._ancestry.join(' / ');
                    }

                    // Add nesting level as a data attribute for potential styling
                    result += `<span class="nested-term nested-samasa" data-type="Samasa" data-nesting-level="${nestingLevel}" data-ancestry="${ancestryInfo}">${samasaContent}</span>`;
                }
            });

            return result;
        }

        // Function to flatten a term and all its nested terms into a single row
        function flattenTerm(term) {
            let result = '';

            // Line number and page link removed

            // Process the term's own content
            result += processTermContent(term);

            // Process morphisms with recursive handling for any nesting level
            if (term._morphisms && term._morphisms.length) {
                result += processMorphisms(term._morphisms);
            }

            // Process samasas with recursive handling for any nesting level
            if (term._samasas && term._samasas.length) {
                result += processSamasas(term._samasas);
            }

            return result;
        }

        // Function to render a term row
        function renderTermRow(term) {
            const rowContent = flattenTerm(term);
            return `<div class="term-row">${rowContent}</div>`;
        }

        // Function to render the current page of terms
        function renderCurrentPage() {
            const termsContainer = document.getElementById('terms-container');
            termsContainer.innerHTML = '';

            const startIndex = currentPage * PAGE_SIZE;
            const endIndex = Math.min(startIndex + PAGE_SIZE, termsData.length);

            for (let i = startIndex; i < endIndex; i++) {
                termsContainer.innerHTML += renderTermRow(termsData[i]);
            }

            // Update pagination info
            if (currentTermId) {
                document.getElementById('pagination-info').textContent = `Term ID: ${currentTermId}`;
                // Show keyboard navigation hint
                document.getElementById('keyboard-hint').style.display = 'block';
            } else {
                document.getElementById('pagination-info').textContent =
                    `Page ${currentPage + 1} of ${Math.ceil(termsData.length / PAGE_SIZE)} (${startIndex + 1}-${endIndex} of ${termsData.length})`;
                // Hide keyboard navigation hint
                document.getElementById('keyboard-hint').style.display = 'none';
            }

            // Update button states
            updateButtonStates();
        }

        // Function to update button states based on current context
        function updateButtonStates() {
            if (currentTermId) {
                // We're viewing a specific term, so prev/next navigate between terms
                document.getElementById('prev-page').disabled = currentTermId <= 1;
                document.getElementById('next-page').disabled = false; // Always allow going to next term
            } else {
                // We're viewing a regular page of terms (e.g., from es.json)
                const startIndex = currentPage * PAGE_SIZE;
                const endIndex = Math.min(startIndex + PAGE_SIZE, termsData.length);
                document.getElementById('prev-page').disabled = currentPage === 0;
                document.getElementById('next-page').disabled = endIndex >= termsData.length;
            }
        }

        // Function to load pagemarks data
        async function loadPagemarks() {
            try {
                const response = await fetch('/pagemarks-data.json');
                if (!response.ok) {
                    throw new Error(`HTTP error! Status: ${response.status}`);
                }
                const data = await response.json();
                pagemarks = data.pagemarks;
                sortedPagemarkKeys = data.sortedKeys;
                console.log(`Pagemarks loaded successfully with ${sortedPagemarkKeys.length} sorted keys`);
                return pagemarks;
            } catch (error) {
                console.error('Error loading pagemarks:', error);
                return {};
            }
        }

        // Function to get page info for a line number using binary search
        function getPageInfo(lineNumber) {
            // Convert lineNumber to a number if it's a string
            lineNumber = parseInt(lineNumber, 10);

            // If no sorted keys are available, return null
            if (!sortedPagemarkKeys || sortedPagemarkKeys.length === 0) {
                return null;
            }

            // Binary search to find the largest key less than or equal to lineNumber
            let left = 0;
            let right = sortedPagemarkKeys.length - 1;
            let result = -1;

            while (left <= right) {
                const mid = Math.floor((left + right) / 2);
                const midKey = sortedPagemarkKeys[mid];

                if (midKey <= lineNumber) {
                    // This key is a candidate, but we need to find the largest such key
                    result = mid;
                    left = mid + 1;
                } else {
                    // This key is too large
                    right = mid - 1;
                }
            }

            // If we found a valid key, extract the page number and create the URL
            if (result !== -1) {
                const maxKey = sortedPagemarkKeys[result];
                const pageMarkValue = pagemarks[maxKey];

                // Extract the page number from the format [Page????-?]...
                const match = pageMarkValue.match(/\[Page([^\]]+)\]/);
                if (match && match[1]) {
                    const pagePart = match[1].split('-')[0].trim();
                    return {
                        url: PAGE_URL_BASE + pagePart,
                        pageNumber: pagePart
                    };
                }
            }

            return null; // Return null if no valid page info could be determined
        }

        // Function to load a single term
        async function loadSingleTerm(termId) {
            try {
                // Check if term is already loaded
                if (loadedTermIds.has(termId)) {
                    return loadedTerms[termId];
                }

                const response = await fetch(`/${termId}.json`);

                if (!response.ok) {
                    // If we get a 404, it might be a gap in the term numbering
                    if (response.status === 404) {
                        console.warn(`Term ${termId} not found, treating as empty`);
                        // Create a placeholder term
                        const placeholderTerm = {
                            __placeholder: true,
                            __termId: termId,
                            _banner: `Term ${termId} not available`
                        };

                        // Store in loaded terms
                        loadedTerms[termId] = [placeholderTerm];
                        loadedTermIds.add(termId);

                        return [placeholderTerm];
                    } else {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                }

                const termData = await response.json();

                // Store in loaded terms
                loadedTerms[termId] = termData;
                loadedTermIds.add(termId);

                return termData;
            } catch (error) {
                console.error(`Error loading term ${termId}:`, error);
                return null;
            }
        }

        // Function to load a term and its context (n-10 to n+10)
        async function loadTermWithContext(termId) {
            try {
                isLoading = true;

                // First load pagemarks if not already loaded
                if (Object.keys(pagemarks).length === 0) {
                    await loadPagemarks();
                }

                // Set current term ID
                currentTermId = termId;

                // Calculate the range of terms to load
                const startTermId = Math.max(1, termId - WINDOW_HALF);
                const endTermId = termId + WINDOW_HALF;

                // Show loading message
                document.getElementById('error').style.display = 'none';
                document.getElementById('loading').style.display = 'block';
                document.getElementById('loading').textContent = `Loading terms ${startTermId} to ${endTermId}...`;

                // Load all terms in the range
                const loadPromises = [];
                for (let id = startTermId; id <= endTermId; id++) {
                    loadPromises.push(loadSingleTerm(id));
                }

                await Promise.all(loadPromises);

                // Hide loading message
                document.getElementById('loading').style.display = 'none';

                // Render the terms
                renderTermsInRange(startTermId, endTermId);

                // Update pagination info
                document.getElementById('pagination-info').textContent = `Term ID: ${currentTermId}`;

                // Show keyboard navigation hint
                document.getElementById('keyboard-hint').style.display = 'block';

                // Update button states
                updateButtonStates();

                // Add scroll event listener if not already added
                if (!window.hasScrollListener) {
                    window.addEventListener('scroll', handleScroll);
                    window.hasScrollListener = true;
                }

                isLoading = false;
            } catch (error) {
                console.error('Error loading terms:', error);
                document.getElementById('loading').style.display = 'none';
                document.getElementById('error').style.display = 'block';
                document.getElementById('error').textContent = `Error loading terms: ${error.message}`;
                isLoading = false;
            }
        }

        // Function to render terms in a specific range
        function renderTermsInRange(startTermId, endTermId) {
            const termsContainer = document.getElementById('terms-container');
            termsContainer.innerHTML = '';

            for (let id = startTermId; id <= endTermId; id++) {
                if (loadedTermIds.has(id)) {
                    const termData = loadedTerms[id];

                    // Create a container for this term
                    const termContainer = document.createElement('div');
                    termContainer.className = 'term-container';
                    termContainer.dataset.termId = id;

                    // No highlighting for current term

                    // Check if it's a placeholder
                    if (termData[0].__placeholder) {
                        termContainer.innerHTML = `<div class="term-row"><em>Term ${id} not available</em></div>`;
                    } else {
                        // Render the term
                        termContainer.innerHTML = termData.map(term => renderTermRow(term)).join('');
                    }

                    termsContainer.appendChild(termContainer);
                }
            }

            // Scroll to the current term
            const currentTermElement = document.querySelector(`.term-container[data-term-id="${currentTermId}"]`);
            if (currentTermElement) {
                currentTermElement.scrollIntoView({ behavior: 'smooth', block: 'center' });
            }
        }

        // Function to load the JSON data (for backward compatibility)
        async function loadTermsData(jsonPath) {
            try {
                isLoading = true;

                // First load pagemarks
                await loadPagemarks();

                // Use the provided path or default
                const path = jsonPath || '/es.json';

                // Extract term ID from path if it's a numeric path
                const termIdMatch = path.match(/\/([0-9]+)\.json$/);
                if (termIdMatch) {
                    // If it's a term ID, use the new loading method
                    const termId = parseInt(termIdMatch[1], 10);
                    await loadTermWithContext(termId);
                    return;
                } else {
                    // For non-term paths (e.g., es.json), use the old method
                    currentTermId = null;
                }

                let response;
                try {
                    response = await fetch(path);
                } catch (e) {
                    console.error('Error fetching from path:', path, e);
                    throw new Error(`Could not fetch from ${path}: ${e.message}`);
                }

                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }

                termsData = await response.json();

                // Hide loading message
                document.getElementById('loading').style.display = 'none';

                // Render the first page
                renderCurrentPage();

                isLoading = false;
            } catch (error) {
                console.error('Error loading terms data:', error);
                document.getElementById('loading').style.display = 'none';
                document.getElementById('error').style.display = 'block';
                document.getElementById('error').textContent = `Error loading data: ${error.message}`;
                isLoading = false;
            }
        }

        // Event listeners for pagination
        document.getElementById('prev-page').addEventListener('click', () => {
            if (currentTermId) {
                // We're viewing a specific term, so go to the previous term
                if (currentTermId > 1 && !isLoading) {
                    navigateToTerm(currentTermId - 1);
                }
            } else if (currentPage > 0) {
                // Regular pagination within a page of terms
                currentPage--;
                renderCurrentPage();
                window.scrollTo(0, 0);
            }
        });

        document.getElementById('next-page').addEventListener('click', () => {
            if (currentTermId) {
                // We're viewing a specific term, so go to the next term
                if (!isLoading) {
                    navigateToTerm(currentTermId + 1);
                }
            } else if ((currentPage + 1) * PAGE_SIZE < termsData.length) {
                // Regular pagination within a page of terms
                currentPage++;
                renderCurrentPage();
                window.scrollTo(0, 0);
            }
        });

        // Function to navigate to a specific term
        function navigateToTerm(termId) {
            if (isLoading) return;

            // Parse termId as integer
            termId = parseInt(termId, 10);
            if (isNaN(termId) || termId <= 0) {
                alert('Please enter a valid Term ID');
                return;
            }

            // Clear any previous errors
            document.getElementById('error').style.display = 'none';
            document.getElementById('loading').style.display = 'block';
            document.getElementById('loading').textContent = `Loading Term ID: ${termId}...`;

            // Update URL without reloading the page
            const newUrl = new URL(window.location.href);
            newUrl.searchParams.set('path', `/${termId}.json`);
            window.history.pushState({}, '', newUrl.toString());

            // Load the term and its context
            loadTermWithContext(termId);
        }

        // No file input handling needed

        // Default path for the JSON file
        const DEFAULT_JSON_PATH = '/es.json'; // When using the server, this will be served from apteDir.nosync/output/es.json

        // Function to get URL parameters
        function getUrlParameter(name) {
            name = name.replace(/[\[]/, '\\[').replace(/[\]]/, '\\]');
            const regex = new RegExp('[\\?&]' + name + '=([^&#]*)');
            const results = regex.exec(location.search);
            return results === null ? '' : decodeURIComponent(results[1].replace(/\+/g, ' '));
        }

        // No default path button anymore

        // Event listener for the load term ID button
        document.getElementById('load-term-id').addEventListener('click', function() {
            const termId = document.getElementById('term-id-input').value.trim();
            if (!termId) {
                alert('Please enter a Term ID');
                return;
            }

            // Navigate to the term
            navigateToTerm(termId);
        });

        // Also handle Enter key in the input field
        document.getElementById('term-id-input').addEventListener('keypress', function(event) {
            if (event.key === 'Enter') {
                event.preventDefault();
                document.getElementById('load-term-id').click();
            }
        });

        // Add keyboard navigation
        document.addEventListener('keydown', function(event) {
            // Only handle keyboard navigation when viewing a specific term
            if (!currentTermId) return;

            // Left arrow key - previous term
            if (event.key === 'ArrowLeft' && currentTermId > 1 && !isLoading) {
                navigateToTerm(currentTermId - 1);
            }

            // Right arrow key - next term
            if (event.key === 'ArrowRight' && !isLoading) {
                navigateToTerm(currentTermId + 1);
            }
        });

        // Scroll event handler for infinite scrolling
        let scrollTimeout;
        let lastBottomTermId = null;
        let lastTopTermId = null;

        function handleScroll() {
            // Add debug element to show scroll info
            let debugEl = document.getElementById('scroll-debug');
            if (!debugEl) {
                debugEl = document.createElement('div');
                debugEl.id = 'scroll-debug';
                debugEl.style.position = 'fixed';
                debugEl.style.bottom = '10px';
                debugEl.style.right = '10px';
                debugEl.style.backgroundColor = 'rgba(0,0,0,0.7)';
                debugEl.style.color = 'white';
                debugEl.style.padding = '10px';
                debugEl.style.borderRadius = '5px';
                debugEl.style.zIndex = '1000';
                debugEl.style.fontSize = '12px';
                document.body.appendChild(debugEl);
            }

            if (scrollTimeout || isLoading || !currentTermId) {
                debugEl.innerHTML = `Waiting: timeout=${!!scrollTimeout}, loading=${isLoading}, currentTermId=${currentTermId}`;
                return;
            }

            // Get viewport dimensions
            const scrollPosition = window.scrollY;
            const windowHeight = window.innerHeight;
            const documentHeight = document.documentElement.scrollHeight;
            const headerHeight = document.getElementById('header').offsetHeight;

            // Adjust scroll position to account for fixed header
            const effectiveScrollPosition = scrollPosition + headerHeight;

            // Get all loaded term IDs in order
            const termContainers = document.querySelectorAll('.term-container');
            const loadedIds = Array.from(termContainers).map(container =>
                parseInt(container.dataset.termId, 10)).sort((a, b) => a - b);

            // Find the highest and lowest loaded term IDs
            const lowestLoadedId = loadedIds.length > 0 ? loadedIds[0] : currentTermId;
            const highestLoadedId = loadedIds.length > 0 ? loadedIds[loadedIds.length - 1] : currentTermId;

            // Update debug display
            debugEl.innerHTML = `Scroll: ${scrollPosition}px<br>
                Effective Scroll: ${effectiveScrollPosition}px<br>
                Window Height: ${windowHeight}px<br>
                Document Height: ${documentHeight}px<br>
                Header Height: ${headerHeight}px<br>
                Lowest ID: ${lowestLoadedId}<br>
                Highest ID: ${highestLoadedId}<br>
                Current ID: ${currentTermId}<br>
                Near Top: ${scrollPosition < 200}<br>
                Near Bottom: ${scrollPosition + windowHeight > documentHeight - 500}`;

            scrollTimeout = setTimeout(() => {
                // Check if we're near the bottom of the page
                // Use a larger threshold for bottom detection to ensure it triggers properly
                const nearBottom = scrollPosition + windowHeight > documentHeight - 500;

                // Check if we're near the top of the content (accounting for fixed header)
                const nearTop = scrollPosition < 200;

                // Near the bottom of the page - load more terms below
                if (nearBottom) {
                    const nextTermId = highestLoadedId + 1;

                    // Only load if we haven't loaded this term before or if it's different from the last one we tried to load
                    if (nextTermId !== lastBottomTermId && !loadedTermIds.has(nextTermId) && nextTermId > 0) {
                        console.log(`Loading more terms below: ${nextTermId}`);
                        debugEl.innerHTML += `<br><strong>Loading below: ${nextTermId}</strong>`;
                        lastBottomTermId = nextTermId;
                        loadMoreTerms(nextTermId, 'below');
                    } else {
                        debugEl.innerHTML += `<br>Not loading below: nextTermId=${nextTermId}, lastBottomTermId=${lastBottomTermId}, already loaded=${loadedTermIds.has(nextTermId)}`;
                    }
                }

                // Near the top of the page - load more terms above
                if (nearTop && lowestLoadedId > 1) {
                    const prevTermId = lowestLoadedId - 1;

                    // Only load if we haven't loaded this term before or if it's different from the last one we tried to load
                    if (prevTermId !== lastTopTermId && !loadedTermIds.has(prevTermId) && prevTermId >= 1) {
                        console.log(`Loading more terms above: ${prevTermId}`);
                        debugEl.innerHTML += `<br><strong>Loading above: ${prevTermId}</strong>`;
                        lastTopTermId = prevTermId;
                        loadMoreTerms(prevTermId, 'above');
                    } else {
                        debugEl.innerHTML += `<br>Not loading above: prevTermId=${prevTermId}, lastTopTermId=${lastTopTermId}, already loaded=${loadedTermIds.has(prevTermId)}`;
                    }
                }

                // Update current term ID based on scroll position
                updateCurrentTermIdFromScroll();

                scrollTimeout = null;
            }, 200);
        }

        // Function to load more terms in a specific direction
        async function loadMoreTerms(termId, direction) {
            if (isLoading || !termId || termId < 1) return;

            // Check if this term is already loaded
            if (document.querySelector(`.term-container[data-term-id="${termId}"]`)) {
                console.log(`Term ${termId} is already in the DOM, skipping`);
                return;
            }

            try {
                isLoading = true;

                // Load the term
                const termData = await loadSingleTerm(termId);

                if (termData) {
                    // Double-check that the term hasn't been added while we were loading
                    if (document.querySelector(`.term-container[data-term-id="${termId}"]`)) {
                        console.log(`Term ${termId} was added while loading, skipping`);
                        isLoading = false;
                        return;
                    }

                    // Get the terms container
                    const termsContainer = document.getElementById('terms-container');

                    // Create a container for this term
                    const termContainer = document.createElement('div');
                    termContainer.className = 'term-container';
                    termContainer.dataset.termId = termId;

                    // Check if it's a placeholder
                    if (termData[0].__placeholder) {
                        termContainer.innerHTML = `<div class="term-row"><em>Term ${termId} not available</em></div>`;
                    } else {
                        // Render the term
                        termContainer.innerHTML = termData.map(term => renderTermRow(term)).join('');
                    }

                    // Add to the DOM in the appropriate position
                    if (direction === 'above') {
                        // Save current scroll position and document height
                        const oldScrollY = window.scrollY;
                        const oldDocumentHeight = document.documentElement.scrollHeight;

                        // Add the new term at the top
                        termsContainer.insertBefore(termContainer, termsContainer.firstChild);
                        console.log(`Added term ${termId} at the top`);

                        // Wait for the DOM to update
                        setTimeout(() => {
                            // Calculate how much the document height changed
                            const newDocumentHeight = document.documentElement.scrollHeight;
                            const heightDifference = newDocumentHeight - oldDocumentHeight;

                            // Adjust scroll position to maintain the same view
                            if (heightDifference > 0) {
                                window.scrollTo(0, oldScrollY + heightDifference);
                                console.log(`Adjusted scroll position by ${heightDifference}px (from ${oldScrollY} to ${oldScrollY + heightDifference})`);
                            }
                        }, 0);
                    } else {
                        termsContainer.appendChild(termContainer);
                        console.log(`Added term ${termId} at the bottom`);
                    }

                    // Trim excess terms to maintain the window size
                    trimExcessTerms();
                }

                isLoading = false;
            } catch (error) {
                console.error(`Error loading more terms:`, error);
                isLoading = false;
            }
        }

        // Function to trim excess terms to maintain the window size
        function trimExcessTerms() {
            const termContainers = document.querySelectorAll('.term-container');
            if (termContainers.length <= WINDOW_SIZE * 2) return; // Keep a buffer

            // Get the current term element
            const currentTermElement = document.querySelector(`.term-container[data-term-id="${currentTermId}"]`);
            if (!currentTermElement) return;

            // Calculate which terms to keep
            const termIds = Array.from(termContainers).map(container => parseInt(container.dataset.termId, 10));
            const minKeepId = Math.max(1, currentTermId - WINDOW_SIZE);
            const maxKeepId = currentTermId + WINDOW_SIZE;

            // Remove terms that are too far from the current term
            for (const container of termContainers) {
                const termId = parseInt(container.dataset.termId, 10);
                if (termId < minKeepId || termId > maxKeepId) {
                    container.remove();
                }
            }
        }

        // Function to update current term ID based on scroll position
        function updateCurrentTermIdFromScroll() {
            const termContainers = document.querySelectorAll('.term-container');
            if (!termContainers.length) return;

            // Get header height to adjust calculations
            const headerHeight = document.getElementById('header').offsetHeight;

            // Find the term closest to the center of the viewport (adjusted for header)
            const viewportMiddle = (window.innerHeight - headerHeight) / 2 + headerHeight;
            let closestTerm = null;
            let closestDistance = Infinity;

            for (const container of termContainers) {
                const rect = container.getBoundingClientRect();
                const termMiddle = rect.top + rect.height / 2;
                const distance = Math.abs(termMiddle - viewportMiddle);

                if (distance < closestDistance) {
                    closestDistance = distance;
                    closestTerm = container;
                }
            }

            if (closestTerm) {
                const newTermId = parseInt(closestTerm.dataset.termId, 10);

                // Only update if it changed
                if (newTermId !== currentTermId) {
                    // Update current term ID
                    currentTermId = newTermId;

                    // Update URL without reloading the page
                    const newUrl = new URL(window.location.href);
                    newUrl.searchParams.set('path', `/${currentTermId}.json`);
                    window.history.pushState({}, '', newUrl.toString());

                    // Update pagination info
                    document.getElementById('pagination-info').textContent = `Term ID: ${currentTermId}`;

                    // Update button states
                    updateButtonStates();
                }
            }
        }

        // Load data only if path parameter is provided in URL
        document.addEventListener('DOMContentLoaded', function() {
            // Check if path is provided in URL
            const jsonPath = getUrlParameter('path');
            if (jsonPath) {
                loadTermsData(jsonPath);
            } else {
                // Hide loading message if no path is provided
                document.getElementById('loading').style.display = 'none';
            }
        });
    </script>
</body>
</html>
