<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Term Viewer</title>
    <script src="sanscript.js"></script>
    <style>
        body {
            font-family: 'Arial', sans-serif;
            line-height: 1.6;
            margin: 0;
            padding: 20px;
            background-color: #f5f5f5;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .scroll-loading-indicator {
            position: fixed;
            left: 50%;
            transform: translateX(-50%);
            width: auto; /* Auto width to fit content */
            min-width: 40px; /* Minimum width */
            text-align: center;
            padding: 6px 10px; /* Reduced padding */
            background-color: rgba(255, 255, 255, 0.95);
            border: 1px solid #4CAF50;
            font-size: 14px;
            color: #333;
            z-index: 90;
            display: none;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            border-radius: 20px;
        }

        #loading-top {
            top: 80px; /* Just below the header */
        }

        #loading-bottom {
            bottom: 20px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding-left: 40px; /* Make room for term IDs */
        }

        h1 {
            text-align: center;
            margin-bottom: 20px;
        }

        .term-row {
            background-color: white;
            padding: 12px;
            margin-bottom: 0;
            overflow-wrap: break-word;
            word-wrap: break-word;
            hyphens: auto;
        }

        /* Line number styling removed */

        .ancestry {
            display: inline;
            color: #555;
            font-style: italic;
            margin-right: 10px;
        }

        .banner {
            display: inline;
            font-weight: bold;
            margin-right: 10px;
            position: relative;
            cursor: default; /* Use default cursor instead of help */
        }

        /* Tooltip for banner */
        .banner::after {
            content: attr(data-tooltip);
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            background-color: #333;
            color: white;
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 0.8em;
            white-space: nowrap;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.2s, visibility 0.2s;
            z-index: 100;
        }

        .banner:hover::after {
            opacity: 1;
            visibility: visible;
        }

        .gram {
            display: inline;
            color: #0066cc;
            margin-right: 10px;
        }

        .meaning {
            display: inline;
            margin-right: 10px;
            cursor: default; /* Use default cursor instead of pointer */
        }

        /* Add hover effect for banner and meaning */
        .banner:hover, .meaning:hover {
            background-color: rgba(0, 0, 0, 0.05); /* Mild highlight on hover */
            border-radius: 2px;
        }

        .meaning-number {
            font-weight: bold;
        }

        .special-text {
            color: #9c7c38; /* Teak wood color - matching Devanagari */
            font-style: italic;
        }

        .devanagari {
            font-family: 'Noto Sans Devanagari', 'Sanskrit 2003', sans-serif;
            font-size: 1.1em;
            color: #9c7c38; /* Teak wood color - warm golden brown */
            font-weight: 500; /* Slightly bolder for better readability */
        }

        /* Smaller font for Devanagari text within meaning elements */
        .meaning .devanagari {
            font-size: 0.95em;
        }

        .warning-symbol {
            color: red;
            font-weight: bold;
        }

        .loading {
            text-align: center;
            padding: 5px;
            font-size: 0.9em;
            color: #666;
            width: auto;
            max-width: 200px;
            margin: 10px auto;
        }

        .scroll-loading-indicator {
            text-align: center;
            padding: 3px;
            font-size: 0.8em;
            color: #888;
            width: auto;
            max-width: 100px;
            margin: 5px auto;
            display: none;
        }

        .error {
            color: #d32f2f;
            text-align: center;
            padding: 10px;
            font-size: 1.1em;
            width: auto;
            max-width: 300px;
            margin: 20px auto;
            background-color: rgba(255, 255, 255, 0.95);
            border: 1px solid #d32f2f;
            border-radius: 20px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        }

        /* Nested term sections */
        .nested-term {
            display: inline;
            position: relative;
            border-radius: 3px;
            border: 1px solid transparent;
            padding: 1px 2px;
            margin: 0 1px;
            cursor: default; /* Use default cursor instead of pointer */
        }

        /* Add hover effect for nested terms */
        .nested-term:hover {
            background-color: rgba(0, 0, 0, 0.05); /* Mild highlight on hover */
        }

        /* Left border only for nested terms */
        .nested-morphism {
            border-color: transparent;
            border-left: 3px solid rgba(0, 100, 200, 0.3);
            background-color: transparent;
            padding-left: 4px;
        }

        .nested-samasa {
            border-color: transparent;
            border-left: 3px solid rgba(150, 0, 200, 0.3);
            background-color: transparent;
            padding-left: 4px;
        }

        /* Nested items with different nesting levels */
        /* Level 0 (first level) */
        .nested-morphism[data-nesting-level="0"] {
            border-left: 3px solid rgba(0, 100, 200, 0.3);
            margin-left: 2px;
        }

        .nested-samasa[data-nesting-level="0"] {
            border-left: 3px solid rgba(150, 0, 200, 0.3);
            margin-left: 2px;
        }

        /* Level 1 (second level) */
        .nested-morphism[data-nesting-level="1"] {
            border-left: 3px solid rgba(0, 100, 200, 0.5);
            margin-left: 2px;
        }

        .nested-samasa[data-nesting-level="1"] {
            border-left: 3px solid rgba(150, 0, 200, 0.5);
            margin-left: 2px;
        }

        /* Level 2 (third level) */
        .nested-morphism[data-nesting-level="2"] {
            border-left: 3px solid rgba(0, 100, 200, 0.7);
            margin-left: 2px;
        }

        .nested-samasa[data-nesting-level="2"] {
            border-left: 3px solid rgba(150, 0, 200, 0.7);
            margin-left: 2px;
        }

        /* Level 3+ (fourth level and beyond) */
        .nested-morphism[data-nesting-level="3"],
        .nested-morphism[data-nesting-level="4"] {
            border-left: 3px solid rgba(0, 100, 200, 0.9);
            margin-left: 2px;
        }

        .nested-samasa[data-nesting-level="3"],
        .nested-samasa[data-nesting-level="4"] {
            border-left: 3px solid rgba(150, 0, 200, 0.9);
            margin-left: 2px;
        }

        /* Cross-nested items (morphism in samasa or vice versa) */
        .nested-term .nested-term {
            margin-left: 2px;
        }

        /* Hover effect - slightly darker left border */
        .nested-morphism:hover {
            border-left-color: rgba(0, 100, 200, 0.8);
        }

        .nested-samasa:hover {
            border-left-color: rgba(150, 0, 200, 0.8);
        }

        /* Pagination */
        .pagination {
            display: flex;
            justify-content: center;
            margin: 20px 0;
        }

        .pagination button {
            background-color: #4CAF50;
            color: white;
            border: none;
            padding: 8px 16px;
            margin: 0 5px;
            cursor: pointer;
            border-radius: 4px;
        }

        .pagination button:disabled {
            background-color: #cccccc;
            cursor: not-allowed;
        }

        .pagination-info {
            margin: 0 15px;
            line-height: 32px;
        }

        /* Styling for infinite scroll */
        .term-container {
            margin-bottom: 0;
            position: relative;
            border-top: 1px solid #e0e0e0;
        }

        .term-container:first-child {
            border-top: none;
        }

        /* Highlighting for the looked-up term */
        .term-container.highlighted {
            background: linear-gradient(to right, rgba(235, 248, 255, 0.3) 0%, rgba(240, 249, 255, 0.1) 100%); /* Subtle gradient background */
            border-left: 2px solid rgba(49, 130, 206, 0.5); /* Subtle blue left border */
            margin-left: -2px; /* Offset the border to maintain alignment */
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.05); /* Very subtle shadow */
            position: relative;
            padding-top: 3px; /* Reduced padding */
            padding-bottom: 3px; /* Reduced padding */
            margin-top: 2px; /* Reduced space above */
            margin-bottom: 2px; /* Reduced space below */
            border-radius: 2px; /* Subtle rounded corners */
        }

        .term-container.highlighted .term-row {
            background: transparent; /* Make the row background transparent to show the container gradient */
        }

        .term-container.highlighted .banner {
            font-weight: 500; /* Semi-bold instead of bold */
            color: #2b6cb0; /* Brighter blue for the banner */
            text-decoration: none; /* No underline */
            font-size: 1em; /* Normal font size */
        }

        .term-container.highlighted .meaning {
            color: #2d3748; /* Slightly darker than normal text */
            font-weight: normal; /* Normal weight */
        }

        /* Specific highlighting for nested elements that match the search */
        .nested-term.search-match {
            background-color: rgba(252, 241, 184, 1); /* Very light yellow background */
            padding: 2px 4px;
            margin: 0 2px;
            border-radius: 2px;
        }

        .nested-term.search-match .banner,
        .nested-term.search-match .meaning {
            color: #7c2d12; /* Dark orange-brown */
            font-weight: 500; /* Semi-bold instead of bold */
        }

        .term-container::before {
            content: attr(data-term-id);
            position: absolute;
            left: -40px;
            top: 15px;
            color: #999;
            font-size: 0.9em;
        }

        /* Suggestion item styling */
        .suggestion-item {
            padding: 8px 12px;
            cursor: pointer;
            border-bottom: 1px solid #eee;
        }

        .suggestion-item:last-child {
            border-bottom: none;
        }

        .suggestion-item:hover {
            background-color: #f5f5f5;
        }

        .suggestion-text {
            font-family: 'Noto Sans Devanagari', 'Sanskrit 2003', sans-serif;
            color: #9c7c38;
            font-weight: 500;
        }

        .suggestion-label {
            font-size: 0.8em;
            color: #666;
            margin-left: 5px;
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- Header with search functionality - fixed at top -->
        <div id="header" style="position: fixed; top: 0; left: 0; right: 0; background-color: #f5f5f5; box-shadow: 0 2px 5px rgba(0,0,0,0.1); padding: 15px; z-index: 100;">
            <div id="file-selector" style="text-align: center;">
                <div style="display: flex; justify-content: center; align-items: center;">
                    <div style="display: flex; align-items: center; position: relative;">
                        <input type="text" id="devanagari-input" placeholder="Enter Devanagari Word (e.g., अंकः)" style="padding: 8px; width: 300px; margin-right: 10px;">
                        <div id="suggestions-container" style="display: none; position: absolute; top: 100%; left: 0; width: 300px; max-height: 300px; overflow-y: auto; background-color: white; border: 1px solid #ddd; border-radius: 4px; z-index: 1000; box-shadow: 0 2px 5px rgba(0,0,0,0.2);"></div>
                        <button id="lookup-devanagari" style="background-color: #4CAF50; color: white; border: none; padding: 8px 16px; cursor: pointer; border-radius: 4px;">Search</button>
                    </div>
                </div>
            </div>
            <!-- Hidden pagination controls -->
            <div style="display: none;">
                <span id="pagination-info">Page 1</span>
                <button id="prev-page" disabled>Previous</button>
                <button id="next-page">Next</button>
            </div>
        </div>

        <!-- Spacer to push content below the fixed header -->
        <div id="header-spacer"></div>

        <!-- Main content area -->
        <div id="content-area">
            <!-- Loading indicator -->
            <div id="loading" class="loading">
                <div style="display: inline-block; animation: spin 1s linear infinite; font-size: 16px; margin-right: 5px;">⟳</div>
                <span>Loading...</span>
            </div>

            <!-- Error message -->
            <div id="error" class="error" style="display: none;"></div>

            <!-- Keyboard navigation hint for top of page -->
            <div id="keyboard-hint-top" style="text-align: center; margin: 5px 0; font-size: 12px; color: #777; display: none;">
                Hit the ↑ key to see previous entries
            </div>

            <!-- Terms container -->
            <div id="terms-container"></div>

            <!-- Scroll loading indicators -->
            <div id="load-more-top-button" style="text-align: center; margin: 10px 0; display: none;">
                <button id="load-more-top" style="background-color: #4CAF50; color: white; border: none; padding: 8px 16px; cursor: pointer; border-radius: 4px;">Load More Above ▲</button>
            </div>

            <div id="loading-top" class="scroll-loading-indicator">
                <div style="display: inline-block; animation: spin 1s linear infinite; font-size: 14px; margin-right: 3px;">⟳</div>
                <span>Loading...</span>
            </div>
            <div id="loading-bottom" class="scroll-loading-indicator">
                <div style="display: inline-block; animation: spin 1s linear infinite; font-size: 14px; margin-right: 3px;">⟳</div>
                <span>Loading...</span>
            </div>

            <!-- Keyboard navigation hint for bottom of page -->
            <div id="keyboard-hint-bottom" style="text-align: center; margin: 5px 0; font-size: 12px; color: #777; display: none;">
                Hit the ↓ key to see more entries
            </div>
        </div>
    </div>

    <script>
        // Configuration
        const PAGE_SIZE = 20;
        let currentPage = 0;
        let termsData = [];
        let pagemarks = {}; // Will store the pagemarks data
        let sortedPagemarkKeys = []; // Will store the sorted keys for binary search
        let currentTermId = null; // Current term ID being viewed
        let requestedTermId = null; // Track the term that was specifically requested
        let searchedWord = null; // Store the Devanagari word that was searched
        let isLoading = false; // Flag to prevent multiple simultaneous loads

        // Infinite scroll configuration`
        const WINDOW_SIZE = 16; // Current term + 15 after
        const WINDOW_BEFORE = 0; // 0 terms before
        const WINDOW_AFTER = 15; // 15 terms after
        let loadedTerms = {}; // Map of termId -> term data
        let loadedTermIds = new Set(); // Set of loaded term IDs

        // Predictive text configuration
        let parsedTableData = []; // Will store the parsed table data as arrays
        const INITIAL_SUGGESTIONS_COUNT = 15; // Initial number of suggestions to collect
        const MAX_SUGGESTIONS = 7; // Maximum number of suggestions to show after filtering
        window.suggestionToEntryMap = new Map(); // Map from suggestion text to entry ID and label

        // Base URL for page links
        const PAGE_URL_BASE = "https://www.sanskrit-lexicon.uni-koeln.de/scans/csl-apidev/servepdf.php?dict=AP90&page=";

        // Function to process special text formatting
        function processSpecialText(text) {
            if (!text) return '';

            // Convert SLP1 encoded Sanskrit text in {# #} brackets to Devanagari
            text = text.replace(/\{#(.*?)#\}/g, function(match, p1) {
                try {
                    // Convert SLP1 to Devanagari
                    const devanagari = Sanscript.t(p1, 'slp1', 'devanagari');
                    return `<span class="devanagari">${devanagari}</span>`;
                } catch (e) {
                    // If conversion fails, just return the original text with special styling
                    return `<span class="special-text">${p1}</span>`;
                }
            });

            // Remove {% %} brackets but style the content differently
            text = text.replace(/\{%(.*?)%\}/g, '<span class="special-text">$1</span>');

            // Remove <ab> </ab> tags but style the content differently
            text = text.replace(/<ab>(.*?)<\/ab>/g, '<span class="special-text">$1</span>');

            return text;
        }

        // Function to process special text formatting without special styling (for banner text)
        function processPlainText(text) {
            if (!text) return '';

            // Convert SLP1 encoded Sanskrit text in {# #} brackets to Devanagari
            text = text.replace(/\{#(.*?)#\}/g, function(match, p1) {
                try {
                    // Convert SLP1 to Devanagari
                    return Sanscript.t(p1, 'slp1', 'devanagari');
                } catch (e) {
                    // If conversion fails, just return the original text
                    return p1;
                }
            });

            // Remove {% %} brackets without special styling
            text = text.replace(/\{%(.*?)%\}/g, '$1');

            // Remove <ab> </ab> tags without special styling
            text = text.replace(/<ab>(.*?)<\/ab>/g, '$1');

            return text;
        }

        // Function to process meaning text with numbered meanings
        function processMeaning(text) {
            if (!text) return '';

            // Normalize all whitespace (including newlines) to a single space
            text = text.replace(/\s+/g, ' ');

            // Handle {@--n@} format at the beginning of meanings
            text = text.replace(/\{@--(\d+)@\}/g, '<span class="meaning-number">$1</span> ');

            // Handle {n} format at the beginning of meanings
            text = text.replace(/^\{(\d+)\}\s*/g, '<span class="meaning-number">$1</span> ');

            return text;
        }

        // Function to process banner expansion
        function processBannerExp(term) {
            // If no _bannerExp, return just the _banner
            if (!term._bannerExp || !term._bannerExp.length) {
                if (term._banner) {
                    // Process special formatting but keep the text in black
                    // No warning symbol, keeping it minimal
                    return {
                        text: processPlainText(term._banner),
                        tooltip: 'No expansion available',
                        isExpanded: false,
                        matchesSearch: false
                    };
                }
                return { text: '', tooltip: '', isExpanded: false, matchesSearch: false };
            }

            // Extract all 'Right' values from _bannerExp
            const rightValues = term._bannerExp
                .filter(item => item.Right)
                .map(item => item.Right);

            // If there are Right values, use them
            if (rightValues.length > 0) {
                // Convert SLP1 to Devanagari for each Right value and check for matches
                let matchesSearch = false;
                const convertedValues = rightValues.map(value => {
                    try {
                        // Check if the value looks like Sanskrit (contains SLP1 characters)
                        // This regex checks for common SLP1 characters that indicate Sanskrit
                        if (/[AIUFXEOMNHSZR]|[kKgGNcCjJYwWqQRtTdDnpPbBmyrlvSzshL]/.test(value)) {
                            const devanagari = Sanscript.t(value, 'slp1', 'devanagari');

                            // Check if this matches the searched word
                            if (searchedWord && devanagari === searchedWord) {
                                matchesSearch = true;
                                console.log(`Found match for '${searchedWord}' in term:`, term);
                            }

                            return `<span class="devanagari">${devanagari}</span>`;
                        } else {
                            // Check if this matches the searched word (for non-Sanskrit)
                            if (searchedWord && value === searchedWord) {
                                matchesSearch = true;
                                console.log(`Found match for '${searchedWord}' in term:`, term);
                            }
                            return value; // Not Sanskrit, return as is
                        }
                    } catch (e) {
                        return value; // If conversion fails, return original
                    }
                });

                return {
                    text: convertedValues.sort().join(', '),
                    tooltip: term._banner ? `${processPlainText(term._banner)}` : '',
                    isExpanded: true,
                    matchesSearch: matchesSearch
                };
            }

            // If all are Left values, use just the _banner
            if (term._banner) {
                // Process special formatting but keep the text in black
                // No warning symbol, keeping it minimal
                return {
                    text: processPlainText(term._banner),
                    tooltip: 'Couldn\'t expand',
                    isExpanded: false,
                    matchesSearch: false
                };
            }

            // Fallback
            return { text: '', tooltip: '', isExpanded: false, matchesSearch: false };
        }

        // Function to process a term's basic content (banner, grammar, meanings)
        function processTermContent(term) {
            let content = '';
            let matchesSearch = false;

            // Process banner/bannerExp
            const bannerInfo = processBannerExp(term);
            if (bannerInfo.text) {
                content += `<span class="banner" data-tooltip="${bannerInfo.tooltip}">${bannerInfo.text}</span>`;
                matchesSearch = bannerInfo.matchesSearch;
            }

            // Grammar info
            if (term._gram && term._gram.length) {
                content += `<span class="gram">${term._gram.map(processSpecialText).join(' ')}</span>`;
            }

            // Meanings
            if (term._meanings && term._meanings.length) {
                term._meanings.forEach(meaning => {
                    content += `<span class="meaning">${processMeaning(processSpecialText(meaning))}</span>`;
                });
            }

            return { content, matchesSearch };
        }

        // Recursive function to process morphisms at any nesting level
        function processMorphisms(morphisms, nestingLevel = 0) {
            if (!morphisms || !morphisms.length) return { html: '', hasMatch: false };

            let result = '';
            let hasMatch = false;

            morphisms.forEach(morphism => {
                const { content: morphismContent, matchesSearch } = processTermContent(morphism);
                let nestedContent = '';
                let nestedHasMatch = false;

                // Process nested morphisms recursively
                if (morphism._morphisms && morphism._morphisms.length) {
                    const nestedMorphisms = processMorphisms(morphism._morphisms, nestingLevel + 1);
                    nestedContent += nestedMorphisms.html;
                    if (nestedMorphisms.hasMatch) nestedHasMatch = true;
                }

                // Process nested samasas if any
                if (morphism._samasas && morphism._samasas.length) {
                    const nestedSamasas = processSamasas(morphism._samasas, nestingLevel + 1);
                    nestedContent += nestedSamasas.html;
                    if (nestedSamasas.hasMatch) nestedHasMatch = true;
                }

                // Add the morphism content to the result if not empty
                if (morphismContent || nestedContent) {
                    // Get ancestry info if available
                    let ancestryInfo = '';
                    if (morphism._ancestry && morphism._ancestry.length) {
                        ancestryInfo = morphism._ancestry.join(' / ');
                    }

                    // Determine if this morphism or any of its children match the search
                    const thisMatchesSearch = matchesSearch || nestedHasMatch;
                    if (thisMatchesSearch) hasMatch = true;

                    // Add appropriate classes based on search match
                    const searchMatchClass = thisMatchesSearch ? ' search-match' : '';

                    // Add nesting level as a data attribute for potential styling
                    result += `<span class="nested-term nested-morphism${searchMatchClass}" data-type="Morphism" data-nesting-level="${nestingLevel}" data-ancestry="${ancestryInfo}">${morphismContent}${nestedContent}</span>`;
                }
            });

            return { html: result, hasMatch };
        }

        // Recursive function to process samasas at any nesting level
        function processSamasas(samasas, nestingLevel = 0) {
            if (!samasas || !samasas.length) return { html: '', hasMatch: false };

            let result = '';
            let hasMatch = false;

            samasas.forEach(samasa => {
                const { content: samasaContent, matchesSearch } = processTermContent(samasa);
                let nestedContent = '';
                let nestedHasMatch = false;

                // Process nested samasas recursively
                if (samasa._samasas && samasa._samasas.length) {
                    const nestedSamasas = processSamasas(samasa._samasas, nestingLevel + 1);
                    nestedContent += nestedSamasas.html;
                    if (nestedSamasas.hasMatch) nestedHasMatch = true;
                }

                // Process nested morphisms if any
                if (samasa._morphisms && samasa._morphisms.length) {
                    const nestedMorphisms = processMorphisms(samasa._morphisms, nestingLevel + 1);
                    nestedContent += nestedMorphisms.html;
                    if (nestedMorphisms.hasMatch) nestedHasMatch = true;
                }

                // Add the samasa content to the result if not empty
                if (samasaContent || nestedContent) {
                    // Get ancestry info if available
                    let ancestryInfo = '';
                    if (samasa._ancestry && samasa._ancestry.length) {
                        ancestryInfo = samasa._ancestry.join(' / ');
                    }

                    // Determine if this samasa or any of its children match the search
                    const thisMatchesSearch = matchesSearch || nestedHasMatch;
                    if (thisMatchesSearch) hasMatch = true;

                    // Add appropriate classes based on search match
                    const searchMatchClass = thisMatchesSearch ? ' search-match' : '';

                    // Add nesting level as a data attribute for potential styling
                    result += `<span class="nested-term nested-samasa${searchMatchClass}" data-type="Samasa" data-nesting-level="${nestingLevel}" data-ancestry="${ancestryInfo}">${samasaContent}${nestedContent}</span>`;
                }
            });

            return { html: result, hasMatch };
        }

        // Function to flatten a term and all its nested terms into a single row
        function flattenTerm(term) {
            let result = '';
            let hasMatch = false;

            // Line number and page link removed

            // Process the term's own content
            const { content: termContent, matchesSearch } = processTermContent(term);
            result += termContent;
            if (matchesSearch) hasMatch = true;

            // Process morphisms with recursive handling for any nesting level
            if (term._morphisms && term._morphisms.length) {
                const morphismsResult = processMorphisms(term._morphisms);
                result += morphismsResult.html;
                if (morphismsResult.hasMatch) hasMatch = true;
            }

            // Process samasas with recursive handling for any nesting level
            if (term._samasas && term._samasas.length) {
                const samasasResult = processSamasas(term._samasas);
                result += samasasResult.html;
                if (samasasResult.hasMatch) hasMatch = true;
            }

            return { content: result, hasMatch };
        }

        // Function to render a term row
        function renderTermRow(term) {
            const { content: rowContent, hasMatch } = flattenTerm(term);
            const matchClass = hasMatch ? ' has-match' : '';
            return `<div class="term-row${matchClass}">${rowContent}</div>`;
        }

        // Function to render the current page of terms
        function renderCurrentPage() {
            const termsContainer = document.getElementById('terms-container');
            termsContainer.innerHTML = '';

            const startIndex = currentPage * PAGE_SIZE;
            const endIndex = Math.min(startIndex + PAGE_SIZE, termsData.length);

            for (let i = startIndex; i < endIndex; i++) {
                termsContainer.innerHTML += renderTermRow(termsData[i]);
            }

            // Update pagination info
            if (currentTermId) {
                document.getElementById('pagination-info').textContent = `Term ID: ${currentTermId}`;
                // Show keyboard navigation hint
                document.getElementById('keyboard-hint-top').style.display = 'block';
                document.getElementById('keyboard-hint-bottom').style.display = 'block';
            } else {
                document.getElementById('pagination-info').textContent =
                    `Page ${currentPage + 1} of ${Math.ceil(termsData.length / PAGE_SIZE)} (${startIndex + 1}-${endIndex} of ${termsData.length})`;
                // Hide keyboard navigation hints
                document.getElementById('keyboard-hint-top').style.display = 'none';
                document.getElementById('keyboard-hint-bottom').style.display = 'none';
            }

            // Update button states
            updateButtonStates();
        }

        // Function to update button states based on current context
        function updateButtonStates() {
            if (currentTermId) {
                // We're viewing a specific term, so prev/next navigate between terms
                document.getElementById('prev-page').disabled = currentTermId <= 1;
                document.getElementById('next-page').disabled = false; // Always allow going to next term
            } else {
                // We're viewing a regular page of terms (e.g., from es.json)
                const startIndex = currentPage * PAGE_SIZE;
                const endIndex = Math.min(startIndex + PAGE_SIZE, termsData.length);
                document.getElementById('prev-page').disabled = currentPage === 0;
                document.getElementById('next-page').disabled = endIndex >= termsData.length;
            }
        }

        // Function to load pagemarks data
        async function loadPagemarks() {
            try {
                const response = await fetch('/pagemarks-data.json');
                if (!response.ok) {
                    throw new Error(`HTTP error! Status: ${response.status}`);
                }
                const data = await response.json();
                pagemarks = data.pagemarks;
                sortedPagemarkKeys = data.sortedKeys;
                console.log(`Pagemarks loaded successfully with ${sortedPagemarkKeys.length} sorted keys`);
                return pagemarks;
            } catch (error) {
                console.error('Error loading pagemarks:', error);
                return {};
            }
        }

        // Function to get page info for a line number using binary search
        function getPageInfo(lineNumber) {
            // Convert lineNumber to a number if it's a string
            lineNumber = parseInt(lineNumber, 10);

            // If no sorted keys are available, return null
            if (!sortedPagemarkKeys || sortedPagemarkKeys.length === 0) {
                return null;
            }

            // Binary search to find the largest key less than or equal to lineNumber
            let left = 0;
            let right = sortedPagemarkKeys.length - 1;
            let result = -1;

            while (left <= right) {
                const mid = Math.floor((left + right) / 2);
                const midKey = sortedPagemarkKeys[mid];

                if (midKey <= lineNumber) {
                    // This key is a candidate, but we need to find the largest such key
                    result = mid;
                    left = mid + 1;
                } else {
                    // This key is too large
                    right = mid - 1;
                }
            }

            // If we found a valid key, extract the page number and create the URL
            if (result !== -1) {
                const maxKey = sortedPagemarkKeys[result];
                const pageMarkValue = pagemarks[maxKey];

                // Extract the page number from the format [Page????-?]...
                const match = pageMarkValue.match(/\[Page([^\]]+)\]/);
                if (match && match[1]) {
                    const pagePart = match[1].split('-')[0].trim();
                    return {
                        url: PAGE_URL_BASE + pagePart,
                        pageNumber: pagePart
                    };
                }
            }

            return null; // Return null if no valid page info could be determined
        }

        // Function to load a single term
        // Make it globally accessible
        window.loadSingleTerm = async function(termId) {
            try {
                // Check if term is already loaded
                if (loadedTermIds.has(termId)) {
                    return loadedTerms[termId];
                }

                // Log 5: Request for term-id file sent
                console.log(`5. Request for term-id file sent: /${termId}.json`);

                const response = await fetch(`/${termId}.json`);

                if (!response.ok) {
                    // If we get a 404, it might be a gap in the term numbering
                    if (response.status === 404) {
                        console.warn(`Term ${termId} not found, treating as empty`);
                        // Create a placeholder term
                        const placeholderTerm = {
                            __placeholder: true,
                            __termId: termId,
                            _banner: `Term ${termId} not available`
                        };

                        // Store in loaded terms
                        loadedTerms[termId] = [placeholderTerm];
                        loadedTermIds.add(termId);

                        return [placeholderTerm];
                    } else {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                }

                const termData = await response.json();

                // Log 6: Term-id received
                console.log(`6. Term-id received: ${termId}`);

                // Store in loaded terms
                loadedTerms[termId] = termData;
                loadedTermIds.add(termId);

                return termData;
            } catch (error) {
                console.error(`Error loading term ${termId}:`, error);
                return null;
            }
        }

        // Function to reset scroll and loading states
        function resetScrollStates() {
            // Reset all scroll and loading related variables
            scrollTimeout = null;
            lastBottomTermId = null;
            lastTopTermId = null;
            isLoadingTop = false;
            isLoadingBottom = false;

            // Debug mode constant (should match the one in handleScroll)
            const DEBUG_MODE = false;

            // Clear any existing debug info
            const debugEl = document.getElementById('scroll-debug');
            if (debugEl) {
                // Remove debug element
                debugEl.remove();
            }
        }

        // Function to load a term and its context (n-10 to n+10)
        // Returns a Promise that resolves when loading is complete
        async function loadTermWithContext(termId) {
            return new Promise(async (resolve, reject) => {
                try {
                    isLoading = true;

                    // Reset scroll states at the beginning of loading a new term
                    resetScrollStates();

                    // First load pagemarks if not already loaded
                    if (Object.keys(pagemarks).length === 0) {
                        await loadPagemarks();
                    }

                    // Set current term ID and requested term ID
                    currentTermId = termId;
                    requestedTermId = termId; // This is the term the user specifically requested

                    // Calculate the range of terms to load
                    const startTermId = termId; // Start from the current term (no terms before)
                    const endTermId = termId + WINDOW_AFTER; // Load 15 terms after

                    // Show loading message
                    document.getElementById('error').style.display = 'none';
                    document.getElementById('loading').style.display = 'block';
                    document.getElementById('loading').innerHTML = `
                        <div style="display: inline-block; animation: spin 1s linear infinite; font-size: 24px; margin-right: 10px;">⟳</div>
                        <span>Loading dictionary...</span>
                    `;

                    // Set a safety timeout to ensure the loading message doesn't get stuck
                    const loadingTimeout = setTimeout(() => {
                        console.warn('Safety timeout reached for term loading, clearing loading message');
                        document.getElementById('loading').style.display = 'none';
                    }, 10000); // 10 second timeout

                    // Load all terms in the range
                    const loadPromises = [];
                    for (let id = startTermId; id <= endTermId; id++) {
                        loadPromises.push(loadSingleTerm(id));
                    }

                    await Promise.all(loadPromises);

                    // Clear the safety timeout
                    clearTimeout(loadingTimeout);

                    // Hide loading message
                    document.getElementById('loading').style.display = 'none';

                    // Render the terms
                    renderTermsInRange(startTermId, endTermId);

                    // Log 7: Term was rendered
                    console.log(`7. Term was rendered: ${termId}`);

                    // Update pagination info - don't show term IDs to the user
                    document.getElementById('pagination-info').textContent = `Dictionary entry`;

                    // Show keyboard navigation hints
                    document.getElementById('keyboard-hint-top').style.display = 'block';
                    document.getElementById('keyboard-hint-bottom').style.display = 'block';

                    // Update button states
                    updateButtonStates();

                    // Add scroll event listener if not already added
                    if (!window.hasScrollListener) {
                        window.addEventListener('scroll', handleScroll);
                        window.hasScrollListener = true;

                        // Helper function to load more terms above when at the top
                        function loadMoreTermsAbove() {
                            if (lowestLoadedId <= 1 || isLoadingTop) {
                                return;
                            }

                            // Trigger loading of previous terms
                            const prevTermId = lowestLoadedId - 1;
                            const batchStartId = Math.max(1, prevTermId - BATCH_SIZE + 1);

                            // Show loading indicator
                            document.getElementById('loading-top').style.display = 'block';
                            isLoadingTop = true;

                            // Reset lastTopTermId to allow loading
                            lastTopTermId = null;

                            // Load each term in the batch
                            const loadPromises = [];
                            for (let id = prevTermId; id >= batchStartId; id--) {
                                loadPromises.push(loadMoreTerms(id, 'above'));
                            }

                            // Hide loading indicator when all terms are loaded
                            Promise.all(loadPromises).finally(() => {
                                setTimeout(() => {
                                    document.getElementById('loading-top').style.display = 'none';
                                    isLoadingTop = false;
                                }, 300);
                            });
                        }

                        // Local wheel event listener removed - using global wheel event listener instead

                        // Local keyboard event listener removed - using global keyboard event listener instead
                    }

                    isLoading = false;
                    resolve();
                } catch (error) {
                    console.error('Error loading terms:', error);

                    // Make sure to clear any loading timeouts
                    if (typeof loadingTimeout !== 'undefined') {
                        clearTimeout(loadingTimeout);
                    }

                    // Hide loading message and show error
                    document.getElementById('loading').style.display = 'none';
                    document.getElementById('error').style.display = 'block';
                    document.getElementById('error').textContent = `Error loading terms: ${error.message}`;
                    document.getElementById('keyboard-hint').style.display = 'none';
                    isLoading = false;
                    reject(error);
                }
        });
        }

        // Function to render terms in a specific range
        function renderTermsInRange(startTermId, endTermId) {
            const termsContainer = document.getElementById('terms-container');
            termsContainer.innerHTML = '';

            for (let id = startTermId; id <= endTermId; id++) {
                if (loadedTermIds.has(id)) {
                    const termData = loadedTerms[id];

                    // Create a container for this term
                    const termContainer = document.createElement('div');
                    termContainer.className = 'term-container';
                    termContainer.dataset.termId = id;

                    // Add highlighting class if this is the requested term
                    if (id === requestedTermId) {
                        termContainer.classList.add('highlighted');
                    }

                    // Check if it's a placeholder
                    if (termData[0].__placeholder) {
                        termContainer.innerHTML = `<div class="term-row"><em>Term ${id} not available</em></div>`;
                    } else {
                        // Render the term
                        termContainer.innerHTML = termData.map(term => renderTermRow(term)).join('');
                    }

                    termsContainer.appendChild(termContainer);
                }
            }

            // Scroll to the most granular highlighted element after a short delay
            // to ensure all DOM updates are complete
            setTimeout(() => {
                scrollToHighlightedElement(currentTermId);
            }, 50);
        }

        // Function to load the JSON data (for backward compatibility)
        async function loadTermsData(jsonPath) {
            try {
                isLoading = true;

                // First load pagemarks
                await loadPagemarks();

                // Check if there's a word parameter in the URL
                const wordParam = getUrlParameter('word');
                if (wordParam) {
                    // If there's a word parameter, look it up
                    await lookupDevanagariWord(wordParam);
                    return;
                }

                // Check if there's a path parameter in the URL
                const pathParam = getUrlParameter('path');
                if (pathParam) {
                    // Extract term ID from path if it's a numeric path
                    const termIdMatch = pathParam.match(/\/([0-9]+)\.json$/);
                    if (termIdMatch) {
                        // If it's a term ID, use the new loading method
                        const termId = parseInt(termIdMatch[1], 10);

                        // Update URL to remove the path parameter
                        const newUrl = new URL(window.location.href);
                        // Clear any existing parameters
                        Array.from(newUrl.searchParams.keys()).forEach(key => {
                            newUrl.searchParams.delete(key);
                        });
                        // Store the term ID in a hidden state for internal use
                        window.currentTermState = { termId: termId };
                        window.history.replaceState(window.currentTermState, '', newUrl.toString());

                        await loadTermWithContext(termId);
                        return;
                    }
                }

                // Use the provided path or default
                const path = jsonPath || '/es.json';

                // Extract term ID from path if it's a numeric path
                const termIdMatch = path.match(/\/([0-9]+)\.json$/);
                if (termIdMatch) {
                    // If it's a term ID, use the new loading method
                    const termId = parseInt(termIdMatch[1], 10);
                    await loadTermWithContext(termId);
                    return;
                } else {
                    // For non-term paths (e.g., es.json), use the old method
                    currentTermId = null;
                }

                let response;
                try {
                    response = await fetch(path);
                } catch (e) {
                    console.error('Error fetching from path:', path, e);
                    throw new Error(`Could not fetch from ${path}: ${e.message}`);
                }

                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }

                termsData = await response.json();

                // Hide loading message
                document.getElementById('loading').style.display = 'none';

                // Hide keyboard hint
                document.getElementById('keyboard-hint').style.display = 'none';

                // Render the first page
                renderCurrentPage();

                isLoading = false;
            } catch (error) {
                console.error('Error loading terms data:', error);
                document.getElementById('loading').style.display = 'none';
                document.getElementById('error').style.display = 'block';
                document.getElementById('error').textContent = `Error loading data: ${error.message}`;
                document.getElementById('keyboard-hint').style.display = 'none';
                isLoading = false;
            }
        }

        // Event listeners for pagination
        document.getElementById('prev-page').addEventListener('click', () => {
            if (currentTermId) {
                // We're viewing a specific term, so go to the previous term
                if (currentTermId > 1 && !isLoading) {
                    navigateToTerm(currentTermId - 1);
                }
            } else if (currentPage > 0) {
                // Regular pagination within a page of terms
                currentPage--;
                renderCurrentPage();
                window.scrollTo(0, 0);
            }
        });

        document.getElementById('next-page').addEventListener('click', () => {
            if (currentTermId) {
                // We're viewing a specific term, so go to the next term
                if (!isLoading) {
                    navigateToTerm(currentTermId + 1);
                }
            } else if ((currentPage + 1) * PAGE_SIZE < termsData.length) {
                // Regular pagination within a page of terms
                currentPage++;
                renderCurrentPage();
                window.scrollTo(0, 0);
            }
        });

        // Function to scroll to the most granular highlighted element
        function scrollToHighlightedElement(termId) {
            // Cancel any existing scroll timeout to prevent conflicts
            if (scrollTimeout) {
                clearTimeout(scrollTimeout);
                scrollTimeout = null;
            }

            // Wait a short time to ensure the DOM is fully updated
            setTimeout(() => {
                const termElement = document.querySelector(`.term-container[data-term-id="${termId}"]`);
                if (!termElement) {
                    return;
                }

                // Simply scroll to the top of the page
                window.scrollTo({
                    top: 0,
                    behavior: 'auto'
                });

                // In case top=0 already and hence handleScroll didn't trigger
                if(!window.termViewerState.lowestLoadedId)
                    window.termViewerState.lowestLoadedId = termId;
            }, 100); // Wait for DOM updates to complete
        }

        // Function to navigate to a specific term
        // Returns a Promise that resolves when navigation is complete
        function navigateToTerm(termId) {
            return new Promise((resolve, reject) => {
                if (isLoading) return resolve();

                // Parse termId as integer
                termId = parseInt(termId, 10);
                if (isNaN(termId) || termId <= 0) {
                    alert('Please enter a valid Term ID');
                    return resolve();
                }

                // Reset scroll states to prevent incorrect scrolling
                resetScrollStates();

                // Force scroll to top to reset view
                window.scrollTo(0, 0);

                // Clear any previous errors
                document.getElementById('error').style.display = 'none';
                document.getElementById('loading').style.display = 'block';
                document.getElementById('loading').innerHTML = `
                <div style="display: inline-block; animation: spin 1s linear infinite; font-size: 16px; margin-right: 5px;">⟳</div>
                <span>Loading...</span>
            `;

                // Set a safety timeout to ensure the loading message doesn't get stuck
                const navTimeout = setTimeout(() => {
                    console.warn('Safety timeout reached for term navigation, clearing loading message');
                    document.getElementById('loading').style.display = 'none';
                }, 10000); // 10 second timeout

                // Update URL without reloading the page, but don't expose term IDs
                // Instead, use a more user-friendly URL format
                const newUrl = new URL(window.location.href);
                // Clear any existing parameters
                Array.from(newUrl.searchParams.keys()).forEach(key => {
                    newUrl.searchParams.delete(key);
                });
                // Store the term ID in a hidden state for internal use
                window.currentTermState = { termId: termId };
                window.history.pushState(window.currentTermState, '', newUrl.toString());

                // Load the term and its context
                loadTermWithContext(termId).then(() => {
                    // Clear the navigation timeout when loading completes
                    clearTimeout(navTimeout);
                    resolve();
                }).catch(error => {
                    // Clear the navigation timeout when loading fails
                    clearTimeout(navTimeout);
                    reject(error);
                });
            });
        }

        // No file input handling needed

        // Default path for the JSON file
        const DEFAULT_JSON_PATH = '/es.json'; // When using the server, this will be served from apteDir.nosync/output/es.json

        // Function to get URL parameters
        function getUrlParameter(name) {
            name = name.replace(/[\[]/, '\\[').replace(/[\]]/, '\\]');
            const regex = new RegExp('[\\?&]' + name + '=([^&#]*)');
            const results = regex.exec(location.search);
            return results === null ? '' : decodeURIComponent(results[1].replace(/\+/g, ' '));
        }

        // No default path button anymore

        // Devanagari dependent vowel marks to independent vowels mapping
        const VOWEL_MARKS_TO_VOWELS = {
            '\u093e': '\u0906', // ा -> आ
            '\u093f': '\u0907', // ि -> इ
            '\u0940': '\u0908', // ी -> ई
            '\u0941': '\u0909', // ु -> उ
            '\u0942': '\u090a', // ू -> ऊ
            '\u0943': '\u090b', // ृ -> ऋ
            '\u0944': '\u0960', // ॄ -> ॠ
            '\u0962': '\u090c', // ॢ -> ऌ
            '\u0963': '\u0961', // ॣ -> ॡ
            '\u0945': '\u090f', // ॅ -> ए
            '\u0947': '\u090f', // े -> ए
            '\u0948': '\u0910', // ै -> ऐ
            '\u0949': '\u0913', // ॉ -> ओ
            '\u094b': '\u0913', // ो -> ओ
            '\u094c': '\u0914'  // ौ -> औ
        };

        // Function to convert nasal consonants to anusvara (ं) when followed by consonants from their group
        function anusvarafy(text) {
            if (!text) return '';

            // Define consonant groups
            const groups = {
                'ङ': ['क', 'ख', 'ग', 'घ'],
                'ञ': ['च', 'छ', 'ज', 'झ'],
                'ण': ['ट', 'ठ', 'ड', 'ढ'],
                'न': ['त', 'थ', 'द', 'ध'],
                'म': ['प', 'फ', 'ब', 'भ','म']
            };

            let result = '';

            for (let i = 0; i < text.length; i++) {
                const currentChar = text[i];
                const nextChar = i < text.length - 1 ? text[i + 1] : '';

                // Check if current character is a nasal consonant and next character is in its group
                let shouldConvert = false;

                if (groups[currentChar] && nextChar) {
                    shouldConvert = groups[currentChar].includes(nextChar);
                }

                if (shouldConvert) {
                    // Replace with anusvara
                    result += 'ं';
                } else {
                    // Keep the original character
                    result += currentChar;
                }
            }

            return result;
        }

        // Function to convert Devanagari to intermediate form
        function devanagariToIntermediate(text) {
            // Result buffer
            let result = '';

            // Process each character
            for (let i = 0; i < text.length; i++) {
                const char = text[i];

                // Check if it's a dependent vowel mark
                if (VOWEL_MARKS_TO_VOWELS[char]) {
                    // Convert to independent vowel
                    result += VOWEL_MARKS_TO_VOWELS[char];
                }
                // Check if it's a virama (्)
                else if (char === '\u094d') {
                    // Skip the virama - we don't include it in the intermediate form
                    continue;
                }
                // For all other characters, just add them as is
                else {
                    result += char;
                    const consonants = "कखगघङचछजझञटठडढणतथदधनपफबभमयरलवशषसहळ";
                    if (consonants.includes(char)) {
                        if(i+1 == text.length)
                            result += 'अ';
                        else if(!VOWEL_MARKS_TO_VOWELS[text[i+1]] && text[i+1] != '\u094d')
                            result += 'अ';
                    }
                }
            }

            return result;
        }

        // Mapping from Devanagari to SLP1
        const DEVANAGARI_TO_SLP1 = {
            // Vowels
            'अ': 'a', 'आ': 'A', 'इ': 'i', 'ई': 'I',
            'उ': 'u', 'ऊ': 'U', 'ऋ': 'f', 'ॠ': 'F',
            'ऌ': 'x', 'ॡ': 'X', 'ए': 'e', 'ऐ': 'E',
            'ओ': 'o', 'औ': 'O',

            // Consonants
            'क': 'k', 'ख': 'K', 'ग': 'g', 'घ': 'G', 'ङ': 'N',
            'च': 'c', 'छ': 'C', 'ज': 'j', 'झ': 'J', 'ञ': 'Y',
            'ट': 'w', 'ठ': 'W', 'ड': 'q', 'ढ': 'Q', 'ण': 'R',
            'त': 't', 'थ': 'T', 'द': 'd', 'ध': 'D', 'न': 'n',
            'प': 'p', 'फ': 'P', 'ब': 'b', 'भ': 'B', 'म': 'm',
            'य': 'y', 'र': 'r', 'ल': 'l', 'व': 'v',
            'श': 'S', 'ष': 'z', 'स': 's', 'ह': 'h', 'ळ': 'L',

            // Other marks
            'ं': 'M', 'ः': 'H', 'ँ': '~',

            // Digits
            '०': '0', '१': '1', '२': '2', '३': '3', '४': '4',
            '५': '5', '६': '6', '७': '7', '८': '8', '९': '9'
        };

        // Function to convert intermediate form back to regular Devanagari
        function intermediateToDevanagari(text) {
            if (!text) return '';

            // Convert intermediate Devanagari to SLP1
            let slp1 = '';
            for (let i = 0; i < text.length; i++) {
                const char = text[i];
                if (DEVANAGARI_TO_SLP1[char]) {
                    slp1 += DEVANAGARI_TO_SLP1[char];
                } else {
                    // Pass through any character not in our mapping
                    slp1 += char;
                }
            }

            // Use sanscript.js to convert SLP1 to Devanagari
            try {
                return Sanscript.t(slp1, 'slp1', 'devanagari');
            } catch (e) {
                console.error('Error converting to Devanagari:', e);
                return text; // Return original text if conversion fails
            }
        }

        // Function to find the index of the first entry that is lexicographically equal to or greater than the input
        function findFirstGreaterOrEqual(input) {
            if (!parsedTableData || parsedTableData.length === 0) {
                return -1;
            }

            // Binary search using the (left + 1 < right) pattern
            let left = 0;
            let right = parsedTableData.length - 1;

            // Handle edge cases first
            if (parsedTableData[left][0] >= input) {
                return left; // First element is already >= input
            }

            if (parsedTableData[right][0] < input) {
                return -1; // All elements are < input
            }

            // Main binary search loop
            while (left + 1 < right) {
                const mid = Math.floor(left + (right - left) / 2); // Avoid potential overflow
                const midValue = parsedTableData[mid][0]; // First field (Devanagari text)

                if (midValue >= input) {
                    // This could be our answer or there might be a smaller index
                    right = mid;
                } else {
                    // This is definitely not our answer, look in the right half
                    left = mid;
                }
            }

            // At this point, right is our candidate for the first element >= input
            return right;
        }

        // Function to get suggestions based on input text
        function getSuggestions(input, filterLabel = null) {
            if (!input || input.length === 0) {
                return [];
            }

            // Convert to intermediate form first, then apply anusvarafy
            const intermediateInput = anusvarafy(devanagariToIntermediate(input));

            // Find the first entry that is lexicographically equal to or greater than the input
            const startIndex = findFirstGreaterOrEqual(intermediateInput);
            if (startIndex === -1) {
                return [];
            }

            // Collect initial suggestions (more than we'll eventually show)
            const initialSuggestions = [];
            const seenIntermediateTexts = []; // For tracking duplicates while preserving order

            // Collect up to INITIAL_SUGGESTIONS_COUNT entries
            for (let i = startIndex; i < parsedTableData.length && initialSuggestions.length < INITIAL_SUGGESTIONS_COUNT; i++) {
                const entry = parsedTableData[i];
                const intermediateText = entry[0];
                const entryId = entry[1];
                const entryLabel = entry[2];

                // Skip entries with labels ending with 'M_'
                if (entryLabel && entryLabel.endsWith('M_')) {
                    continue;
                }

                // // If filterLabel is provided, only include entries with matching label
                // if (filterLabel && entryLabel !== filterLabel) {
                //     continue;
                // }

                // Skip duplicates (check intermediate text to maintain order)
                if (seenIntermediateTexts.includes(intermediateText)) {
                    continue;
                }

                // Add to our collection and mark as seen
                initialSuggestions.push({
                    intermediateText,
                    entryId,
                    entryLabel
                });
                seenIntermediateTexts.push(intermediateText);
            }

            // Limit to MAX_SUGGESTIONS
            const finalSuggestions = initialSuggestions.slice(0, MAX_SUGGESTIONS);

            // Now convert to Devanagari and store mappings
            return finalSuggestions.map(item => {
                // Convert the intermediate form back to regular Devanagari
                const suggestion = intermediateToDevanagari(item.intermediateText);

                // Store the mapping from suggestion to entry ID for lookup
                window.suggestionToEntryMap.set(suggestion, {
                    id: item.entryId,
                    label: item.entryLabel
                });

                return suggestion;
            });
        }

        // Function to lookup a word in table_new.txt
        // Returns a Promise that resolves when the lookup is complete
        // isAlternativeAttempt tracks if this is an alternative form lookup
        async function lookupDevanagariWord(word, isAlternativeAttempt = false) {
            return new Promise(async (resolve, reject) => {
                if (isLoading) return resolve();

                if (!word) {
                    alert('Please enter a word');
                    return resolve();
                }

                // Reset scroll states to prevent incorrect scrolling
                resetScrollStates();

                // Force scroll to top to reset view
                window.scrollTo(0, 0);

                // Clean up sliding window and related bookkeeping variables
                // Clear the terms container
                const termsContainer = document.getElementById('terms-container');
                termsContainer.innerHTML = '';

                // Reset the loadedTermIds set
                loadedTermIds.clear();

                // Reset the loadedTerms object
                loadedTerms = {};

                // Reset window state variables
                currentTermId = null;
                requestedTermId = null;
                window.termViewerState.lowestLoadedId = null;
                window.termViewerState.lastTopTermId = null;
                window.termViewerState.isLoadingTop = false;
                lastBottomTermId = null;
                isLoadingBottom = false;

                // Store the searched word for highlighting nested elements
                searchedWord = word.trim();

                // Show loading message
                document.getElementById('error').style.display = 'none';
                document.getElementById('loading').style.display = 'block';
                document.getElementById('loading').innerHTML = `
                <div style="display: inline-block; animation: spin 1s linear infinite; font-size: 16px; margin-right: 5px;">⟳</div>
                <span>Looking up "${word}"...</span>
            `;

                // Set a safety timeout to ensure the loading message doesn't get stuck
                const safetyTimeout = setTimeout(() => {
                    console.warn('Safety timeout reached for word lookup, clearing loading message');
                    document.getElementById('loading').style.display = 'none';
                }, 5000); // 5 second timeout

                try {
                    // Variables for lookup
                    let termId = null;
                    let intermediateFormFound = false;
                    let lookupKey = word.trim();

                    // Convert to intermediate form first, then apply anusvarafy
                    let intermediateForm = anusvarafy(devanagariToIntermediate(lookupKey));
                    console.log(`Converted Devanagari "${lookupKey}" to intermediate form with anusvarafy: "${intermediateForm}"`);

                    // Use the intermediate form for lookup
                    lookupKey = intermediateForm;

                    // Check if we have parsed table data
                    if (parsedTableData && parsedTableData.length > 0) {
                        // Log 2: Using parsed table data
                        console.log('2. Using parsed table data for lookup');

                        // Use binary search to find the exact match
                        const startIndex = findFirstGreaterOrEqual(lookupKey);
                        if (startIndex !== -1 && parsedTableData[startIndex][0] === lookupKey) {
                            // Found an exact match
                            termId = parsedTableData[startIndex][1];
                            intermediateFormFound = true;
                            // Log 3: Term ID found
                            console.log('3. Term ID found:', termId);
                        } else {
                            console.log('No exact match found in parsed table data');
                        }
                    } else if (typeof preloadedTableData !== 'undefined') {
                        // Fallback to the original string-based search if parsed data is not available
                        // Log 2: Using preloaded table data
                        console.log('2. Using preloaded table data for lookup (string-based search)');

                        // Search for the word in the preloaded table data
                        for (const line of preloadedTableData) {
                            if (!line.trim()) continue;

                            const parts = line.split(':').map(part => part.trim());
                            if (parts.length >= 2 && parts[0] === lookupKey) {
                                // Found a match, extract the term ID (second field)
                                const id = parseInt(parts[1], 10);
                                if (!isNaN(id)) {
                                    termId = id;
                                    intermediateFormFound = true;
                                    // Log 3: Term ID found
                                    console.log('3. Term ID found:', id);
                                    break;
                                }
                            }
                        }
                    } else {
                        // Fallback to fetching table_new.txt if preloaded data is not available
                        // Log 2: Request sent for table_new
                        console.log('2. Preloaded data not available, fetching table_new.txt');

                        const response = await fetch('/table_new.txt');
                        if (!response.ok) {
                            clearTimeout(safetyTimeout);
                            throw new Error(`Failed to load table_new.txt: ${response.status} ${response.statusText}`);
                        }

                        // Log 3: table_new received
                        console.log('3. table_new.txt received');

                        const text = await response.text();
                        const lines = text.split('\n');

                        // Search for the word in table_new.txt
                        for (const line of lines) {
                            if (!line.trim()) continue;

                            const parts = line.split(':').map(part => part.trim());
                            if (parts.length >= 2 && parts[0] === lookupKey) {
                                // Found a match, extract the term ID (second field)
                                const id = parseInt(parts[1], 10);
                                if (!isNaN(id)) {
                                    termId = id;
                                    intermediateFormFound = true;
                                    // Log 4: Term ID found
                                    console.log('4. Term ID found:', id);
                                    break;
                                }
                            }
                        }
                    }
                    console.log(`termId  ${termId}`);
                    if (termId) {
                        // Clear the safety timeout since we're navigating to the term
                        clearTimeout(safetyTimeout);

                        // Update URL to show the word being looked up
                        const newUrl = new URL(window.location.href);
                        // Clear any existing parameters
                        Array.from(newUrl.searchParams.keys()).forEach(key => {
                            newUrl.searchParams.delete(key);
                        });
                        // Add the word as a parameter
                        newUrl.searchParams.set('word', word.trim());
                        window.history.pushState({word: word.trim(), termId: termId}, '', newUrl.toString());

                        // Navigate to the term
                        navigateToTerm(termId).finally(() => {
                            resolve();
                        });
                    } else {
                        // Word not found
                        clearTimeout(safetyTimeout);
                        document.getElementById('loading').style.display = 'none';

                        // Hide keyboard hints
                        document.getElementById('keyboard-hint-top').style.display = 'none';
                        document.getElementById('keyboard-hint-bottom').style.display = 'none';

                        // Always reject with information about the attempt
                        reject({
                            word: word,
                            isAlternativeAttempt: isAlternativeAttempt,
                            message: `Word "${word}" not found in dictionary.`
                        });
                    }
                } catch (error) {
                    clearTimeout(safetyTimeout);
                    console.error('Error looking up word:', error);
                    document.getElementById('loading').style.display = 'none';
                    document.getElementById('error').style.display = 'block';
                    document.getElementById('error').textContent = `Error looking up word: ${error.message}`;
                    document.getElementById('keyboard-hint-top').style.display = 'none';
                    document.getElementById('keyboard-hint-bottom').style.display = 'none';
                    reject(error);
                }
            });
        }

        // Term ID input feature has been removed

        // Function to render suggestions
        function renderSuggestions(suggestions) {
            const suggestionsContainer = document.getElementById('suggestions-container');

            // Clear previous suggestions
            suggestionsContainer.innerHTML = '';

            // Reset selected suggestion index
            selectedSuggestionIndex = -1;

            if (suggestions.length === 0) {
                suggestionsContainer.style.display = 'none';
                return;
            }

            // Create suggestion items
            suggestions.forEach(suggestion => {
                const item = document.createElement('div');
                item.className = 'suggestion-item';
                item.innerHTML = `
                    <span class="suggestion-text">${suggestion}</span>
                `;

                // Add click event to select this suggestion
                item.addEventListener('click', () => {
                    // Set the input value to the selected suggestion
                    document.getElementById('devanagari-input').value = suggestion;

                    // Hide suggestions
                    suggestionsContainer.style.display = 'none';

                    // Check if we have the entry ID for this suggestion
                    const entryInfo = window.suggestionToEntryMap.get(suggestion);
                    if (entryInfo && entryInfo.id) {
                        // Create a custom lookup function for the suggestion
                        const lookupSuggestion = async () => {
                            try {
                                // Show loading message
                                document.getElementById('error').style.display = 'none';
                                document.getElementById('loading').style.display = 'block';
                                document.getElementById('loading').innerHTML = `
                                    <div style="display: inline-block; animation: spin 1s linear infinite; font-size: 16px; margin-right: 5px;">⟳</div>
                                    <span>Looking up "${suggestion}"...</span>
                                `;

                                // Update URL to show the word being looked up
                                const newUrl = new URL(window.location.href);
                                // Clear any existing parameters
                                Array.from(newUrl.searchParams.keys()).forEach(key => {
                                    newUrl.searchParams.delete(key);
                                });
                                // Add the word as a parameter
                                newUrl.searchParams.set('word', suggestion);
                                window.history.pushState({word: suggestion, termId: entryInfo.id}, '', newUrl.toString());

                                // Use the term ID directly from the entry info
                                await navigateToTerm(entryInfo.id);

                                // Hide loading message
                                document.getElementById('loading').style.display = 'none';
                            } catch (error) {
                                console.error('Error in suggestion lookup:', error);
                                document.getElementById('loading').style.display = 'none';
                                document.getElementById('error').style.display = 'block';
                                document.getElementById('error').textContent = `Error looking up word: ${error.message}`;
                            }
                        };

                        lookupSuggestion();
                    } else {
                        // Fallback to regular lookup if entry info is not available
                        lookupDevanagariWord(suggestion).catch(error => {
                            console.error('Error in word lookup from suggestion:', error);
                        });
                    }

                    // Defocus the input field
                    document.getElementById('devanagari-input').blur();
                });

                suggestionsContainer.appendChild(item);
            });

            // Show the suggestions container
            suggestionsContainer.style.display = 'block';
        }

        // Event listener for input changes to show suggestions
        document.getElementById('devanagari-input').addEventListener('input', function() {
            const input = this.value.trim();

            if (input.length < 1) {
                // Hide suggestions if input is too short
                document.getElementById('suggestions-container').style.display = 'none';
                return;
            }

            // Get suggestions based on input
            const suggestions = getSuggestions(input);


            // Render suggestions
            renderSuggestions(suggestions);
        });

        // Hide suggestions when clicking outside
        document.addEventListener('click', function(event) {
            const suggestionsContainer = document.getElementById('suggestions-container');
            const inputField = document.getElementById('devanagari-input');

            if (!suggestionsContainer.contains(event.target) && event.target !== inputField) {
                suggestionsContainer.style.display = 'none';
            }
        });

        // Event listener for the lookup Devanagari word button
        document.getElementById('lookup-devanagari').addEventListener('click', function() {
            const inputField = document.getElementById('devanagari-input');
            const word = inputField.value.trim();

            // Log 1: Input submitted by user
            console.log('1. Input submitted by user:', word);

            // Hide suggestions
            document.getElementById('suggestions-container').style.display = 'none';

            // Try to look up the word as entered (not an alternative attempt)
            lookupDevanagariWord(word, false).catch(error => {
                console.error('Initial word lookup failed:', error);

                // Check if this was an original word attempt (not an alternative)
                if (!error.isAlternativeAttempt) {
                    // Check if the last character is in the range [अ, ौ]
                    const lastChar = word.charAt(word.length - 1);
                    const isInRange = lastChar >= 'अ' && lastChar <= 'ौ';

                    if (isInRange) {
                        console.log('Last character is in range [अ, ौ], trying with ः and ं appended');

                        // Try with visarga (ः) appended
                        const wordWithVisarga = word + 'ः';
                        lookupDevanagariWord(wordWithVisarga, true).catch(visargaError => {
                            console.error('Word lookup with visarga failed:', visargaError);

                            // Try with anusvara (ं) appended
                            const wordWithAnusvara = word + 'ं';
                            lookupDevanagariWord(wordWithAnusvara, true).catch(anusvaraError => {
                                console.error('Word lookup with anusvara failed:', anusvaraError);
                                console.error('All lookup attempts failed for word:', word);

                                // All attempts failed - now show the error message
                                document.getElementById('error').style.display = 'block';
                                document.getElementById('error').innerHTML = `Word "${word}" not found in dictionary.`;
                            });
                        });
                    } else {
                        console.error('Last character is not in range [अ, ौ], not trying alternative endings');

                        // Not in range for alternatives - show error immediately
                        document.getElementById('error').style.display = 'block';
                        document.getElementById('error').innerHTML = error.message;
                    }
                } else {
                    // This was already an alternative attempt - just log the failure
                    console.error(`Alternative form "${error.word}" lookup failed`);
                }
            });
            // Defocus the input field to allow normal scrolling with arrow keys
            inputField.blur();
        });

        // Handle keyboard events in the Devanagari input field
        let selectedSuggestionIndex = -1;

        document.getElementById('devanagari-input').addEventListener('keydown', function(event) {
            const suggestionsContainer = document.getElementById('suggestions-container');
            const suggestionItems = suggestionsContainer.querySelectorAll('.suggestion-item');

            // Only process if suggestions are visible
            if (suggestionsContainer.style.display === 'block') {
                if (event.key === 'ArrowDown') {
                    // Move selection down
                    event.preventDefault();
                    selectedSuggestionIndex = Math.min(selectedSuggestionIndex + 1, suggestionItems.length - 1);
                    updateSelectedSuggestion(suggestionItems);
                } else if (event.key === 'ArrowUp') {
                    // Move selection up
                    event.preventDefault();
                    selectedSuggestionIndex = Math.max(selectedSuggestionIndex - 1, -1);
                    updateSelectedSuggestion(suggestionItems);
                } else if (event.key === 'Escape') {
                    // Hide suggestions on Escape
                    event.preventDefault();
                    suggestionsContainer.style.display = 'none';
                    selectedSuggestionIndex = -1;
                }
            }
        });

        // Function to update the selected suggestion
        function updateSelectedSuggestion(suggestionItems) {
            // Remove highlight from all items
            suggestionItems.forEach(item => {
                item.style.backgroundColor = '';
            });

            // Add highlight to selected item
            if (selectedSuggestionIndex >= 0 && selectedSuggestionIndex < suggestionItems.length) {
                suggestionItems[selectedSuggestionIndex].style.backgroundColor = '#f0f0f0';

                // Ensure the selected item is visible in the container
                suggestionItems[selectedSuggestionIndex].scrollIntoView({ block: 'nearest' });
            }
        }

        // Handle Enter key in the Devanagari input field
        document.getElementById('devanagari-input').addEventListener('keypress', function(event) {
            if (event.key === 'Enter') {
                event.preventDefault();

                const suggestionsContainer = document.getElementById('suggestions-container');
                const suggestionItems = suggestionsContainer.querySelectorAll('.suggestion-item');

                // If suggestions are visible and an item is selected, use that
                if (suggestionsContainer.style.display === 'block' &&
                    selectedSuggestionIndex >= 0 &&
                    selectedSuggestionIndex < suggestionItems.length) {

                    // Simulate click on the selected suggestion
                    suggestionItems[selectedSuggestionIndex].click();
                    return;
                }

                // Otherwise, use the input value directly
                const word = this.value.trim();

                // Log 1: Input submitted by user
                console.log('1. INPUT submitted by user:', word);

                // Hide suggestions
                suggestionsContainer.style.display = 'none';
                selectedSuggestionIndex = -1;

                // Try to look up the word as entered (not an alternative attempt)
                lookupDevanagariWord(word, false).catch(error => {
                    console.error('Initial word lookup failed:', error);

                    // Check if this was an original word attempt (not an alternative)
                    if (!error.isAlternativeAttempt) {
                        // Check if the last character is in the range [अ, ौ]
                        const lastChar = word.charAt(word.length - 1);
                        const isInRange = lastChar >= 'अ' && lastChar <= 'ौ';

                        if (isInRange) {
                            console.log('Last character is in range [अ, ौ], trying with ः and ं appended');

                            // Try with visarga (ः) appended
                            const wordWithVisarga = word + 'ः';
                            lookupDevanagariWord(wordWithVisarga, true).catch(visargaError => {
                                console.error('Word lookup with visarga failed:', visargaError);

                                // Try with anusvara (ं) appended
                                const wordWithAnusvara = word + 'ं';
                                lookupDevanagariWord(wordWithAnusvara, true).catch(anusvaraError => {
                                    console.error('Word lookup with anusvara failed:', anusvaraError);
                                    console.error('All lookup attempts failed for word:', word);

                                    // All attempts failed - now show the error message
                                    document.getElementById('error').style.display = 'block';
                                    document.getElementById('error').innerHTML = `Word "${word}" not found in dictionary.`;
                                });
                            });
                        } else {
                            console.error('Last character is not in range [अ, ौ], not trying alternative endings');

                            // Not in range for alternatives - show error immediately
                            document.getElementById('error').style.display = 'block';
                            document.getElementById('error').innerHTML = error.message;
                        }
                    } else {
                        // This was already an alternative attempt - just log the failure
                        console.error(`Alternative form "${error.word}" lookup failed`);
                    }
                });
                // Defocus (blur) the input field to allow normal scrolling with arrow keys
                this.blur();
            }
        });

        // Keyboard navigation has been removed as requested

        // Scroll event handler for infinite scrolling
        let scrollTimeout;
        let lastBottomTermId = null;
        let lastTopTermId = null;
        const BATCH_SIZE = 7; // Load half the WINDOW_AFTER size at once
        const SCROLL_TIMEOUT = 300; // Increased timeout for larger payloads
        let isLoadingTop = false; // Flag to track loading state for top indicator
        let isLoadingBottom = false; // Flag to track loading state for bottom indicator

        function handleScroll() {
            // Debug element code is now disabled
            // Set to true to enable
            const DEBUG_MODE = false;

            let debugEl = document.getElementById('scroll-debug');
            if (DEBUG_MODE) {
                if (!debugEl) {
                    debugEl = document.createElement('div');
                    debugEl.id = 'scroll-debug';
                    debugEl.style.position = 'fixed';
                    debugEl.style.bottom = '10px';
                    debugEl.style.right = '10px';
                    debugEl.style.backgroundColor = 'rgba(0,0,0,0.7)';
                    debugEl.style.color = 'white';
                    debugEl.style.padding = '10px';
                    debugEl.style.borderRadius = '5px';
                    debugEl.style.zIndex = '1000';
                    debugEl.style.fontSize = '12px';
                    document.body.appendChild(debugEl);
                }
            } else if (debugEl) {
                // Remove debug element if it exists and debug mode is off
                debugEl.remove();
                debugEl = null;
            }

            if (scrollTimeout || isLoading || !currentTermId) {
                if (DEBUG_MODE && debugEl) {
                    debugEl.innerHTML = `Waiting: timeout=${!!scrollTimeout}, loading=${isLoading}, currentTermId=${currentTermId}`;
                }
                return;
            }

            // Get viewport dimensions
            const scrollPosition = window.scrollY;
            const windowHeight = window.innerHeight;
            const documentHeight = document.documentElement.scrollHeight;

            // No need to adjust for header since it's now in the normal document flow
            const effectiveScrollPosition = scrollPosition;

            // Get all loaded term IDs in order
            const termContainers = document.querySelectorAll('.term-container');
            const loadedIds = Array.from(termContainers).map(container =>
                parseInt(container.dataset.termId, 10)).sort((a, b) => a - b);

            // Find the highest and lowest loaded term IDs
            const lowestLoadedId = loadedIds.length > 0 ? loadedIds[0] : currentTermId;
            const highestLoadedId = loadedIds.length > 0 ? loadedIds[loadedIds.length - 1] : currentTermId;

            // Update global state
            window.termViewerState.lowestLoadedId = lowestLoadedId;
            window.termViewerState.isLoadingTop = isLoadingTop;

            // Update debug display if debug mode is enabled
            if (DEBUG_MODE && debugEl) {
                debugEl.innerHTML = `Scroll: ${scrollPosition}px<br>
                    Effective Scroll: ${effectiveScrollPosition}px<br>
                    Window Height: ${windowHeight}px<br>
                    Document Height: ${documentHeight}px<br>
                    Lowest ID: ${lowestLoadedId}<br>
                    Highest ID: ${highestLoadedId}<br>
                    Current ID: ${currentTermId}<br>
                    Near Top: ${scrollPosition < 200}<br>
                    Near Bottom: ${scrollPosition + windowHeight > documentHeight - 500}`;
            }

            scrollTimeout = setTimeout(() => {
                // Update current term ID based on scroll position
                updateCurrentTermIdFromScroll();
                scrollTimeout = null;
            }, SCROLL_TIMEOUT);
        }

        // Function to load more terms in a specific direction
        // Make it globally accessible
        window.loadMoreTerms = async function(termId, direction) {
            if (isLoading || !termId || termId < 1) return Promise.resolve();

            // Check if this term is already loaded
            if (document.querySelector(`.term-container[data-term-id="${termId}"]`)) {
                console.log(`Term ${termId} is already in the DOM, skipping`);
                return Promise.resolve();
            }

            try {
                isLoading = true;

                // Load the term
                const termData = await loadSingleTerm(termId);

                if (termData) {
                    // Double-check that the term hasn't been added while we were loading
                    if (document.querySelector(`.term-container[data-term-id="${termId}"]`)) {
                        console.log(`Term ${termId} was added while loading, skipping`);
                        isLoading = false;
                        return;
                    }

                    // Get the terms container
                    const termsContainer = document.getElementById('terms-container');

                    // Create a container for this term
                    const termContainer = document.createElement('div');
                    termContainer.className = 'term-container';
                    termContainer.dataset.termId = termId;

                    // Add highlighting class if this is the requested term
                    if (termId === requestedTermId) {
                        termContainer.classList.add('highlighted');
                    }

                    // Check if it's a placeholder
                    if (termData[0].__placeholder) {
                        termContainer.innerHTML = `<div class="term-row"><em>Term ${termId} not available</em></div>`;
                    } else {
                        // Render the term
                        termContainer.innerHTML = termData.map(term => renderTermRow(term)).join('');
                    }

                    // Add to the DOM in the appropriate position
                    if (direction === 'above') {
                        // Save current scroll position and document height
                        const oldScrollY = window.scrollY;
                        const oldDocumentHeight = document.documentElement.scrollHeight;

                        // Add the new term at the top
                        termsContainer.insertBefore(termContainer, termsContainer.firstChild);
                        console.log(`Added term ${termId} at the top`);

                        // Wait for the DOM to update
                        setTimeout(() => {
                            // Calculate how much the document height changed
                            const newDocumentHeight = document.documentElement.scrollHeight;
                            const heightDifference = newDocumentHeight - oldDocumentHeight;

                            // Adjust scroll position to maintain the same view
                            if (heightDifference > 0) {
                                // Special case: if we were at the top (scrollY === 0), don't adjust scroll position
                                // This allows the user to see the newly loaded content at the top
                                if (oldScrollY === 0) {
                                    console.log('At top of page, not adjusting scroll position to show new content');
                                } else {
                                    // Otherwise, maintain the same view by adjusting scroll position
                                    window.scrollTo(0, oldScrollY + heightDifference);
                                    console.log(`Adjusted scroll position by ${heightDifference}px (from ${oldScrollY} to ${oldScrollY + heightDifference})`);
                                }
                            }
                        }, 0);
                    } else {
                        termsContainer.appendChild(termContainer);
                        console.log(`Added term ${termId} at the bottom`);
                    }

                    // Trim excess terms to maintain the window size
                    trimExcessTerms();
                }

                isLoading = false;
                return Promise.resolve();
            } catch (error) {
                console.error(`Error loading more terms:`, error);
                isLoading = false;
                return Promise.reject(error);
            }
        }

        // Function to trim excess terms to maintain the window size
        function trimExcessTerms() {
            const termContainers = document.querySelectorAll('.term-container');
            if (termContainers.length <= WINDOW_SIZE * 6) return; // Keep an even larger buffer (6x instead of 4x)

            // Get the current term element
            const currentTermElement = document.querySelector(`.term-container[data-term-id="${currentTermId}"]`);
            if (!currentTermElement) return;

            // Calculate which terms to keep - use a wider range than the normal window
            const termIds = Array.from(termContainers).map(container => parseInt(container.dataset.termId, 10));
            let minKeepId = Math.max(0, currentTermId - WINDOW_SIZE);
            let maxKeepId = currentTermId;
            if (termIds.length > 0 && currentTermId === termIds[0]) {
                minKeepId = currentTermId; // Start from the current term (no terms before)
                maxKeepId = currentTermId + WINDOW_AFTER * 2; // Double the keep range for terms after
            }

            // Remove terms that are too far from the current term
            for (const container of termContainers) {
                const termId = parseInt(container.dataset.termId, 10);
                if (termId < minKeepId || termId > maxKeepId) {
                    // Remove from DOM
                    container.remove();

                    // Also remove from loadedTermIds set to allow reloading if needed
                    loadedTermIds.delete(termId);

                    // Reset lastTopTermId and lastBottomTermId if they match the removed term
                    if (termId === lastTopTermId) {
                        lastTopTermId = null;
                    }
                    if (termId === lastBottomTermId) {
                        lastBottomTermId = null;
                    }

                    console.log(`Removed term ${termId} from DOM and tracking`);
                }
            }
        }

        // Function to update current term ID based on scroll position
        function updateCurrentTermIdFromScroll() {
            const termContainers = document.querySelectorAll('.term-container');
            if (!termContainers.length) return;

            // No need to get header height since it's in the normal document flow

            // Find the term closest to the center of the viewport
            const viewportMiddle = window.innerHeight / 2;
            let closestTerm = null;
            let closestDistance = Infinity;

            for (const container of termContainers) {
                const rect = container.getBoundingClientRect();
                const termMiddle = rect.top + rect.height / 2;
                const distance = Math.abs(termMiddle - viewportMiddle);

                if (distance < closestDistance) {
                    closestDistance = distance;
                    closestTerm = container;
                }
            }

            if (closestTerm) {
                const newTermId = parseInt(closestTerm.dataset.termId, 10);

                // Only update if it changed
                if (newTermId !== currentTermId) {
                    // Update current term ID
                    currentTermId = newTermId;

                    // Store the term ID in a hidden state for internal use
                    window.currentTermState = { termId: currentTermId };

                    // Update pagination info - don't show term IDs to the user
                    document.getElementById('pagination-info').textContent = `Dictionary entry`;

                    // Update button states
                    updateButtonStates();
                }
            }
        }

        // Make lowestLoadedId and lastTopTermId globally accessible
        window.termViewerState = {
            lowestLoadedId: null,
            lastTopTermId: null,
            isLoadingTop: false
        };

        // Global wheel event listener for top scrolling - DISABLED
        // We no longer load terms on mouse-based scroll events

        // Global keyboard event listener for arrow keys
        window.addEventListener('keydown', function(event) {
            // Handle up arrow key when at the top
            if (window.scrollY === 0 && (event.key === 'ArrowUp' || event.key === 'Up')) {
                // Check if we're in a term view context
                if (window.termViewerState.lowestLoadedId && window.termViewerState.lowestLoadedId > 1 && !window.termViewerState.isLoadingTop) {
                    // Force reset lastTopTermId to allow loading
                    window.termViewerState.lastTopTermId = null;

                    // Force loading of previous terms
                    // Check if the terms immediately before the lowest loaded term are already in the DOM
                    const lowestLoadedId = window.termViewerState.lowestLoadedId;
                    let prevTermId = lowestLoadedId - 1;

                    // If the previous terms are already loaded, go back further
                    while (prevTermId > 1 && document.querySelector(`.term-container[data-term-id="${prevTermId}"]`)) {
                        prevTermId--;
                    }

                    // Calculate batch start, ensuring we don't go below 1
                    const batchStartId = Math.max(1, prevTermId - 7 + 1); // Use BATCH_SIZE (7)

                    // Show loading indicator
                    document.getElementById('loading-top').style.display = 'block';
                    window.termViewerState.isLoadingTop = true;

                    // Load each term in the batch, but only if it's not already in the DOM
                    const loadPromises = [];
                    for (let id = prevTermId; id >= batchStartId; id--) {
                        // Skip terms that are already in the DOM
                        if (!document.querySelector(`.term-container[data-term-id="${id}"]`)) {
                            if (typeof window.loadMoreTerms === 'function') {
                                loadPromises.push(window.loadMoreTerms(id, 'above'));
                            }
                        }
                    }

                    // Hide loading indicator when all terms are loaded
                    if (loadPromises.length > 0) {
                        Promise.all(loadPromises).finally(() => {
                            setTimeout(() => {
                                document.getElementById('loading-top').style.display = 'none';
                                window.termViewerState.isLoadingTop = false;
                            }, 300);
                        });
                    } else {
                        // If no terms were loaded, hide the indicator
                        setTimeout(() => {
                            document.getElementById('loading-top').style.display = 'none';
                            window.termViewerState.isLoadingTop = false;
                        }, 300);
                    }
                }
            }

            // Handle down arrow key when at the bottom
            if ((window.innerHeight + window.scrollY >= document.body.offsetHeight - 5) &&
                (event.key === 'ArrowDown' || event.key === 'Down')) {
                // Check if we're in a term view context and not already loading
                const termContainers = document.querySelectorAll('.term-container');
                if (termContainers.length > 0 && !isLoadingBottom) {
                    // Get the highest loaded term ID
                    const loadedIds = Array.from(termContainers).map(container =>
                        parseInt(container.dataset.termId, 10)).sort((a, b) => a - b);
                    const highestLoadedId = loadedIds.length > 0 ? loadedIds[loadedIds.length - 1] : currentTermId;

                    // Force reset lastBottomTermId to allow loading
                    lastBottomTermId = null;

                    // Force loading of next terms
                    const nextTermId = highestLoadedId + 1;
                    const batchEndId = nextTermId + BATCH_SIZE - 1;

                    // Show loading indicator
                    document.getElementById('loading-bottom').style.display = 'block';
                    isLoadingBottom = true;

                    // Load each term in the batch
                    const loadPromises = [];
                    for (let id = nextTermId; id <= batchEndId; id++) {
                        // Skip terms that are already in the DOM
                        if (!document.querySelector(`.term-container[data-term-id="${id}"]`)) {
                            if (typeof window.loadMoreTerms === 'function') {
                                loadPromises.push(window.loadMoreTerms(id, 'below'));
                            }
                        }
                    }

                    // Hide loading indicator when all terms are loaded
                    if (loadPromises.length > 0) {
                        Promise.all(loadPromises).finally(() => {
                            setTimeout(() => {
                                document.getElementById('loading-bottom').style.display = 'none';
                                isLoadingBottom = false;
                            }, 300);
                        });
                    } else {
                        // If no terms were loaded, hide the indicator
                        setTimeout(() => {
                            document.getElementById('loading-bottom').style.display = 'none';
                            isLoadingBottom = false;
                        }, 300);
                    }
                }
            }
        });

        // Load data based on URL parameters
        document.addEventListener('DOMContentLoaded', function() {
            // Set header-spacer height to match the header height
            const headerHeight = document.getElementById('header').offsetHeight;
            document.getElementById('header-spacer').style.height = headerHeight + 'px';

            // Update header-spacer height on window resize
            window.addEventListener('resize', function() {
                const headerHeight = document.getElementById('header').offsetHeight;
                document.getElementById('header-spacer').style.height = headerHeight + 'px';
            });

            // Check if we have preloaded table data
            if (typeof preloadedTableData !== 'undefined') {
                console.log(`Preloaded table data available with ${preloadedTableData.length} entries`);

                // Parse the preloaded table data into arrays
                parsedTableData = preloadedTableData.map(line => {
                    if (!line.trim()) return null;
                    const parts = line.split(':').map(part => part.trim());
                    if (parts.length >= 3) {
                        return [parts[0], parseInt(parts[1], 10), parts[2]];
                    } else if (parts.length >= 2) {
                        return [parts[0], parseInt(parts[1], 10), ''];
                    }
                    return null;
                }).filter(item => item !== null);

                console.log(`Parsed table data into ${parsedTableData.length} arrays`);

                // Show a brief message that the dictionary is ready
                document.getElementById('loading').style.display = 'block';
                document.getElementById('loading').innerHTML = `
                    <div style="display: inline-block; font-size: 16px; margin-right: 5px;">✓</div>
                    <span>Dictionary data loaded (${parsedTableData.length} entries)</span>
                `;

                // Hide the message after a short delay
                setTimeout(() => {
                    document.getElementById('loading').style.display = 'none';
                }, 1500);
            }

            // Make sure loading indicators are hidden initially
            document.getElementById('loading-top').style.display = 'none';
            document.getElementById('loading-bottom').style.display = 'none';
            document.getElementById('keyboard-hint-top').style.display = 'none';
            document.getElementById('keyboard-hint-bottom').style.display = 'none';

            // Check if word parameter is provided in URL
            const wordParam = getUrlParameter('word');
            if (wordParam) {
                // If there's a word parameter, look it up
                lookupDevanagariWord(wordParam).catch(error => {
                    console.error('Error in word lookup:', error);
                });
                return;
            }

            // Check if path is provided in URL (for backward compatibility)
            const jsonPath = getUrlParameter('path');
            if (jsonPath) {
                loadTermsData(jsonPath);
            } else {
                // Hide loading message if no parameters are provided
                document.getElementById('loading').style.display = 'none';
                document.getElementById('keyboard-hint-top').style.display = 'none';
                document.getElementById('keyboard-hint-bottom').style.display = 'none';
            }
        });
    </script>
</body>
</html>
