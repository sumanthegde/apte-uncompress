<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Term Viewer</title>
    <script src="sanscript.js"></script>
    <style>
        body {
            font-family: 'Arial', sans-serif;
            line-height: 1.6;
            margin: 0;
            padding: 20px;
            background-color: #f5f5f5;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
        }

        h1 {
            text-align: center;
            margin-bottom: 20px;
        }

        .term-row {
            background-color: white;
            border-radius: 4px;
            padding: 15px;
            margin-bottom: 10px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            overflow-wrap: break-word;
            word-wrap: break-word;
            hyphens: auto;
        }

        .line-number {
            display: inline-block;
            color: #666;
            font-size: 0.9em;
            margin-right: 10px;
            background-color: #f0f0f0;
            padding: 2px 6px;
            border-radius: 3px;
        }

        .ancestry {
            display: inline-block;
            color: #555;
            font-style: italic;
            margin-right: 10px;
        }

        .banner {
            display: inline-block;
            font-weight: bold;
            margin-right: 10px;
            position: relative;
            cursor: help;
        }

        /* Tooltip for banner */
        .banner::after {
            content: attr(data-tooltip);
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            background-color: #333;
            color: white;
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 0.8em;
            white-space: nowrap;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.2s, visibility 0.2s;
            z-index: 100;
        }

        .banner:hover::after {
            opacity: 1;
            visibility: visible;
        }

        .gram {
            display: inline-block;
            color: #0066cc;
            margin-right: 10px;
        }

        .meaning {
            display: inline-block;
            margin-right: 10px;
        }

        .meaning-number {
            font-weight: bold;
        }

        .special-text {
            color: #9c27b0;
            font-style: italic;
        }

        .devanagari {
            font-family: 'Noto Sans Devanagari', 'Sanskrit 2003', sans-serif;
            font-size: 1.1em;
            color: #9c27b0;
        }

        .warning-symbol {
            color: red;
            font-weight: bold;
        }

        .loading {
            text-align: center;
            padding: 20px;
            font-size: 1.2em;
        }

        .error {
            color: red;
            text-align: center;
            padding: 20px;
        }

        /* Nested term sections */
        .nested-term {
            display: inline;
            position: relative;
            border-radius: 3px;
            border: 1px solid transparent;
            padding: 1px 2px;
            margin: 0 1px;
            cursor: pointer;
        }

        /* Left border only for nested terms */
        .nested-morphism {
            border-color: transparent;
            border-left: 3px solid rgba(0, 100, 200, 0.3);
            background-color: transparent;
            padding-left: 4px;
        }

        .nested-samasa {
            border-color: transparent;
            border-left: 3px solid rgba(150, 0, 200, 0.3);
            background-color: transparent;
            padding-left: 4px;
        }

        /* Nested items with different nesting levels */
        /* Level 0 (first level) */
        .nested-morphism[data-nesting-level="0"] {
            border-left: 3px solid rgba(0, 100, 200, 0.3);
            margin-left: 2px;
        }

        .nested-samasa[data-nesting-level="0"] {
            border-left: 3px solid rgba(150, 0, 200, 0.3);
            margin-left: 2px;
        }

        /* Level 1 (second level) */
        .nested-morphism[data-nesting-level="1"] {
            border-left: 3px solid rgba(0, 100, 200, 0.5);
            margin-left: 2px;
        }

        .nested-samasa[data-nesting-level="1"] {
            border-left: 3px solid rgba(150, 0, 200, 0.5);
            margin-left: 2px;
        }

        /* Level 2 (third level) */
        .nested-morphism[data-nesting-level="2"] {
            border-left: 3px solid rgba(0, 100, 200, 0.7);
            margin-left: 2px;
        }

        .nested-samasa[data-nesting-level="2"] {
            border-left: 3px solid rgba(150, 0, 200, 0.7);
            margin-left: 2px;
        }

        /* Level 3+ (fourth level and beyond) */
        .nested-morphism[data-nesting-level="3"],
        .nested-morphism[data-nesting-level="4"] {
            border-left: 3px solid rgba(0, 100, 200, 0.9);
            margin-left: 2px;
        }

        .nested-samasa[data-nesting-level="3"],
        .nested-samasa[data-nesting-level="4"] {
            border-left: 3px solid rgba(150, 0, 200, 0.9);
            margin-left: 2px;
        }

        /* Cross-nested items (morphism in samasa or vice versa) */
        .nested-term .nested-term {
            margin-left: 2px;
        }

        /* Hover effect - slightly darker left border */
        .nested-morphism:hover {
            border-left-color: rgba(0, 100, 200, 0.8);
        }

        .nested-samasa:hover {
            border-left-color: rgba(150, 0, 200, 0.8);
        }

        /* Pagination */
        .pagination {
            display: flex;
            justify-content: center;
            margin: 20px 0;
        }

        .pagination button {
            background-color: #4CAF50;
            color: white;
            border: none;
            padding: 8px 16px;
            margin: 0 5px;
            cursor: pointer;
            border-radius: 4px;
        }

        .pagination button:disabled {
            background-color: #cccccc;
            cursor: not-allowed;
        }

        .pagination-info {
            margin: 0 15px;
            line-height: 32px;
        }
    </style>
</head>
<body>
    <div class="container">
        <div id="file-selector" style="text-align: center; margin-bottom: 20px;">
            <div style="padding: 15px;">
                <div style="display: flex; justify-content: center; align-items: center;">
                    <input type="number" id="term-id-input" placeholder="Enter Term ID (e.g., 9091)" style="padding: 8px; width: 250px; margin-right: 10px;">
                    <button id="load-term-id" style="background-color: #4CAF50; color: white; border: none; padding: 8px 16px; cursor: pointer; border-radius: 4px;">Load Term</button>
                </div>
            </div>
        </div>

        <div id="loading" class="loading">Loading... If this takes too long, try running the server with 'node serve.js' and accessing http://localhost:8081/</div>
        <div id="error" class="error" style="display: none;"></div>

        <div id="terms-container"></div>

        <div class="pagination">
            <button id="prev-page" disabled>Previous</button>
            <span class="pagination-info" id="pagination-info">Page 1</span>
            <button id="next-page">Next</button>
        </div>
    </div>

    <script>
        // Configuration
        const PAGE_SIZE = 20;
        let currentPage = 0;
        let termsData = [];

        // Function to process special text formatting
        function processSpecialText(text) {
            if (!text) return '';

            // Convert SLP1 encoded Sanskrit text in {# #} brackets to Devanagari
            text = text.replace(/\{#(.*?)#\}/g, function(match, p1) {
                try {
                    // Convert SLP1 to Devanagari
                    const devanagari = Sanscript.t(p1, 'slp1', 'devanagari');
                    return `<span class="devanagari">${devanagari}</span>`;
                } catch (e) {
                    // If conversion fails, just return the original text with special styling
                    return `<span class="special-text">${p1}</span>`;
                }
            });

            // Remove {% %} brackets but style the content differently
            text = text.replace(/\{%(.*?)%\}/g, '<span class="special-text">$1</span>');

            // Remove <ab> </ab> tags but style the content differently
            text = text.replace(/<ab>(.*?)<\/ab>/g, '<span class="special-text">$1</span>');

            return text;
        }

        // Function to process special text formatting without special styling (for banner text)
        function processPlainText(text) {
            if (!text) return '';

            // Convert SLP1 encoded Sanskrit text in {# #} brackets to Devanagari
            text = text.replace(/\{#(.*?)#\}/g, function(match, p1) {
                try {
                    // Convert SLP1 to Devanagari
                    return Sanscript.t(p1, 'slp1', 'devanagari');
                } catch (e) {
                    // If conversion fails, just return the original text
                    return p1;
                }
            });

            // Remove {% %} brackets without special styling
            text = text.replace(/\{%(.*?)%\}/g, '$1');

            // Remove <ab> </ab> tags without special styling
            text = text.replace(/<ab>(.*?)<\/ab>/g, '$1');

            return text;
        }

        // Function to process meaning text with numbered meanings
        function processMeaning(text) {
            if (!text) return '';

            // Normalize all whitespace (including newlines) to a single space
            text = text.replace(/\s+/g, ' ');

            // Handle {@--n@} format at the beginning of meanings
            text = text.replace(/\{@--(\d+)@\}/g, '<span class="meaning-number">$1</span> ');

            // Handle {n} format at the beginning of meanings
            text = text.replace(/^\{(\d+)\}\s*/g, '<span class="meaning-number">$1</span> ');

            return text;
        }

        // Function to process banner expansion
        function processBannerExp(term) {
            // If no _bannerExp, return the _banner with warning symbol
            if (!term._bannerExp || !term._bannerExp.length) {
                if (term._banner) {
                    // Process special formatting but keep the text in black
                    // Add warning symbol since there's no _bannerExp
                    return {
                        text: processPlainText(term._banner) + ' <span class="warning-symbol">⚠️</span>',
                        tooltip: 'No expansion available',
                        isExpanded: false
                    };
                }
                return { text: '', tooltip: '', isExpanded: false };
            }

            // Extract all 'Right' values from _bannerExp
            const rightValues = term._bannerExp
                .filter(item => item.Right)
                .map(item => item.Right);

            // If there are Right values, use them
            if (rightValues.length > 0) {
                // Convert SLP1 to Devanagari for each Right value
                const convertedValues = rightValues.map(value => {
                    try {
                        // Check if the value looks like Sanskrit (contains SLP1 characters)
                        // This regex checks for common SLP1 characters that indicate Sanskrit
                        if (/[AIUFXEOMNHSZR]|[kKgGNcCjJYwWqQRtTdDnpPbBmyrlvSzshL]/.test(value)) {
                            return `<span class="devanagari">${Sanscript.t(value, 'slp1', 'devanagari')}</span>`;
                        } else {
                            return value; // Not Sanskrit, return as is
                        }
                    } catch (e) {
                        return value; // If conversion fails, return original
                    }
                });

                return {
                    text: convertedValues.join(', '),
                    //tooltip: term._banner ? `Originally: ${processPlainText(term._banner)}` : '',
                    tooltip: term._banner ? `${processPlainText(term._banner)}` : '',
                    isExpanded: true
                };
            }

            // If all are Left values, use _banner with warning symbol
            if (term._banner) {
                // Process special formatting but keep the text in black
                // Only the warning symbol is red
                return {
                    text: processPlainText(term._banner) + ' <span class="warning-symbol">⚠️</span>',
                    tooltip: 'Couldn\'t expand',
                    isExpanded: false
                };
            }

            // Fallback
            return { text: '', tooltip: '', isExpanded: false };
        }

        // Function to process a term's basic content (banner, grammar, meanings)
        function processTermContent(term) {
            let content = '';

            // Process banner/bannerExp
            const bannerInfo = processBannerExp(term);
            if (bannerInfo.text) {
                content += `<span class="banner" data-tooltip="${bannerInfo.tooltip}">${bannerInfo.text}</span>`;
            }

            // Grammar info
            if (term._gram && term._gram.length) {
                content += `<span class="gram">${term._gram.map(processSpecialText).join(' ')}</span>`;
            }

            // Meanings
            if (term._meanings && term._meanings.length) {
                term._meanings.forEach(meaning => {
                    content += `<span class="meaning">${processMeaning(processSpecialText(meaning))}</span>`;
                });
            }

            return content;
        }

        // Recursive function to process morphisms at any nesting level
        function processMorphisms(morphisms, nestingLevel = 0) {
            if (!morphisms || !morphisms.length) return '';

            let result = '';

            morphisms.forEach(morphism => {
                let morphismContent = processTermContent(morphism);

                // Process nested morphisms recursively
                if (morphism._morphisms && morphism._morphisms.length) {
                    morphismContent += processMorphisms(morphism._morphisms, nestingLevel + 1);
                }

                // Process nested samasas if any
                if (morphism._samasas && morphism._samasas.length) {
                    morphismContent += processSamasas(morphism._samasas, nestingLevel + 1);
                }

                // Add the morphism content to the result if not empty
                if (morphismContent) {
                    // Get ancestry info if available
                    let ancestryInfo = '';
                    if (morphism._ancestry && morphism._ancestry.length) {
                        ancestryInfo = morphism._ancestry.join(' / ');
                    }

                    // Add nesting level as a data attribute for potential styling
                    result += `<span class="nested-term nested-morphism" data-type="Morphism" data-nesting-level="${nestingLevel}" data-ancestry="${ancestryInfo}">${morphismContent}</span>`;
                }
            });

            return result;
        }

        // Recursive function to process samasas at any nesting level
        function processSamasas(samasas, nestingLevel = 0) {
            if (!samasas || !samasas.length) return '';

            let result = '';

            samasas.forEach(samasa => {
                let samasaContent = processTermContent(samasa);

                // Process nested samasas recursively
                if (samasa._samasas && samasa._samasas.length) {
                    samasaContent += processSamasas(samasa._samasas, nestingLevel + 1);
                }

                // Process nested morphisms if any
                if (samasa._morphisms && samasa._morphisms.length) {
                    samasaContent += processMorphisms(samasa._morphisms, nestingLevel + 1);
                }

                // Add the samasa content to the result if not empty
                if (samasaContent) {
                    // Get ancestry info if available
                    let ancestryInfo = '';
                    if (samasa._ancestry && samasa._ancestry.length) {
                        ancestryInfo = samasa._ancestry.join(' / ');
                    }

                    // Add nesting level as a data attribute for potential styling
                    result += `<span class="nested-term nested-samasa" data-type="Samasa" data-nesting-level="${nestingLevel}" data-ancestry="${ancestryInfo}">${samasaContent}</span>`;
                }
            });

            return result;
        }

        // Function to flatten a term and all its nested terms into a single row
        function flattenTerm(term) {
            let result = '';

            // Line number
            if (term.__line) {
                result += `<span class="line-number">${term.__line}</span>`;
            }

            // Process the term's own content
            result += processTermContent(term);

            // Process morphisms with recursive handling for any nesting level
            if (term._morphisms && term._morphisms.length) {
                result += processMorphisms(term._morphisms);
            }

            // Process samasas with recursive handling for any nesting level
            if (term._samasas && term._samasas.length) {
                result += processSamasas(term._samasas);
            }

            return result;
        }

        // Function to render a term row
        function renderTermRow(term) {
            const rowContent = flattenTerm(term);
            return `<div class="term-row">${rowContent}</div>`;
        }

        // Function to render the current page of terms
        function renderCurrentPage() {
            const termsContainer = document.getElementById('terms-container');
            termsContainer.innerHTML = '';

            const startIndex = currentPage * PAGE_SIZE;
            const endIndex = Math.min(startIndex + PAGE_SIZE, termsData.length);

            for (let i = startIndex; i < endIndex; i++) {
                termsContainer.innerHTML += renderTermRow(termsData[i]);
            }

            // Update pagination info
            document.getElementById('pagination-info').textContent =
                `Page ${currentPage + 1} of ${Math.ceil(termsData.length / PAGE_SIZE)} (${startIndex + 1}-${endIndex} of ${termsData.length})`;

            // Update button states
            document.getElementById('prev-page').disabled = currentPage === 0;
            document.getElementById('next-page').disabled = endIndex >= termsData.length;
        }

        // Function to load the JSON data
        async function loadTermsData(jsonPath) {
            try {
                // Use the provided path or default
                const path = jsonPath || '/es.json';

                let response;
                try {
                    response = await fetch(path);
                } catch (e) {
                    console.error('Error fetching from path:', path, e);
                    throw new Error(`Could not fetch from ${path}: ${e.message}`);
                }
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }

                termsData = await response.json();

                // Hide loading message
                document.getElementById('loading').style.display = 'none';

                // Render the first page
                renderCurrentPage();
            } catch (error) {
                console.error('Error loading terms data:', error);
                document.getElementById('loading').style.display = 'none';
                document.getElementById('error').style.display = 'block';
                document.getElementById('error').textContent = `Error loading data: ${error.message}`;
            }
        }

        // Event listeners for pagination
        document.getElementById('prev-page').addEventListener('click', () => {
            if (currentPage > 0) {
                currentPage--;
                renderCurrentPage();
                window.scrollTo(0, 0);
            }
        });

        document.getElementById('next-page').addEventListener('click', () => {
            if ((currentPage + 1) * PAGE_SIZE < termsData.length) {
                currentPage++;
                renderCurrentPage();
                window.scrollTo(0, 0);
            }
        });

        // No file input handling needed

        // Default path for the JSON file
        const DEFAULT_JSON_PATH = '/es.json'; // When using the server, this will be served from apteDir.nosync/output/es.json

        // Function to get URL parameters
        function getUrlParameter(name) {
            name = name.replace(/[\[]/, '\\[').replace(/[\]]/, '\\]');
            const regex = new RegExp('[\\?&]' + name + '=([^&#]*)');
            const results = regex.exec(location.search);
            return results === null ? '' : decodeURIComponent(results[1].replace(/\+/g, ' '));
        }

        // No default path button anymore

        // Event listener for the load term ID button
        document.getElementById('load-term-id').addEventListener('click', function() {
            const termId = document.getElementById('term-id-input').value.trim();
            if (!termId) {
                alert('Please enter a Term ID');
                return;
            }

            // Clear any previous errors
            document.getElementById('error').style.display = 'none';
            document.getElementById('loading').style.display = 'block';
            document.getElementById('loading').textContent = `Loading Term ID: ${termId}...`;

            // Load the term from the sharded JSON file
            loadTermsData(`/${termId}.json`);
        });

        // Also handle Enter key in the input field
        document.getElementById('term-id-input').addEventListener('keypress', function(event) {
            if (event.key === 'Enter') {
                event.preventDefault();
                document.getElementById('load-term-id').click();
            }
        });

        // Load data when the page loads
        document.addEventListener('DOMContentLoaded', function() {
            // Check if path is provided in URL
            const jsonPath = getUrlParameter('path') || DEFAULT_JSON_PATH;
            loadTermsData(jsonPath);
        });
    </script>
</body>
</html>
