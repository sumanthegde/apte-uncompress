<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Term Viewer</title>
    <script src="sanscript.js"></script>
    <style>
        body {
            font-family: 'Arial', sans-serif;
            line-height: 1.6;
            margin: 0;
            padding: 20px;
            background-color: #f5f5f5;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .scroll-loading-indicator {
            position: fixed;
            left: 50%;
            transform: translateX(-50%);
            width: 200px;
            text-align: center;
            padding: 8px;
            background-color: rgba(255, 255, 255, 0.95);
            border: 1px solid #4CAF50;
            font-size: 14px;
            color: #333;
            z-index: 90;
            display: none;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            border-radius: 20px;
        }

        #loading-top {
            top: 80px; /* Just below the header */
        }

        #loading-bottom {
            bottom: 20px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding-left: 40px; /* Make room for term IDs */
        }

        h1 {
            text-align: center;
            margin-bottom: 20px;
        }

        .term-row {
            background-color: white;
            padding: 12px;
            margin-bottom: 0;
            overflow-wrap: break-word;
            word-wrap: break-word;
            hyphens: auto;
        }

        /* Line number styling removed */

        .ancestry {
            display: inline;
            color: #555;
            font-style: italic;
            margin-right: 10px;
        }

        .banner {
            display: inline;
            font-weight: bold;
            margin-right: 10px;
            position: relative;
            cursor: help;
        }

        /* Tooltip for banner */
        .banner::after {
            content: attr(data-tooltip);
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            background-color: #333;
            color: white;
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 0.8em;
            white-space: nowrap;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.2s, visibility 0.2s;
            z-index: 100;
        }

        .banner:hover::after {
            opacity: 1;
            visibility: visible;
        }

        .gram {
            display: inline;
            color: #0066cc;
            margin-right: 10px;
        }

        .meaning {
            display: inline;
            margin-right: 10px;
        }

        .meaning-number {
            font-weight: bold;
        }

        .special-text {
            color: #9c27b0;
            font-style: italic;
        }

        .devanagari {
            font-family: 'Noto Sans Devanagari', 'Sanskrit 2003', sans-serif;
            font-size: 1.1em;
            color: #9c27b0;
        }

        .warning-symbol {
            color: red;
            font-weight: bold;
        }

        .loading {
            text-align: center;
            padding: 20px;
            font-size: 1.2em;
        }

        .error {
            color: red;
            text-align: center;
            padding: 20px;
        }

        /* Nested term sections */
        .nested-term {
            display: inline;
            position: relative;
            border-radius: 3px;
            border: 1px solid transparent;
            padding: 1px 2px;
            margin: 0 1px;
            cursor: pointer;
        }

        /* Left border only for nested terms */
        .nested-morphism {
            border-color: transparent;
            border-left: 3px solid rgba(0, 100, 200, 0.3);
            background-color: transparent;
            padding-left: 4px;
        }

        .nested-samasa {
            border-color: transparent;
            border-left: 3px solid rgba(150, 0, 200, 0.3);
            background-color: transparent;
            padding-left: 4px;
        }

        /* Nested items with different nesting levels */
        /* Level 0 (first level) */
        .nested-morphism[data-nesting-level="0"] {
            border-left: 3px solid rgba(0, 100, 200, 0.3);
            margin-left: 2px;
        }

        .nested-samasa[data-nesting-level="0"] {
            border-left: 3px solid rgba(150, 0, 200, 0.3);
            margin-left: 2px;
        }

        /* Level 1 (second level) */
        .nested-morphism[data-nesting-level="1"] {
            border-left: 3px solid rgba(0, 100, 200, 0.5);
            margin-left: 2px;
        }

        .nested-samasa[data-nesting-level="1"] {
            border-left: 3px solid rgba(150, 0, 200, 0.5);
            margin-left: 2px;
        }

        /* Level 2 (third level) */
        .nested-morphism[data-nesting-level="2"] {
            border-left: 3px solid rgba(0, 100, 200, 0.7);
            margin-left: 2px;
        }

        .nested-samasa[data-nesting-level="2"] {
            border-left: 3px solid rgba(150, 0, 200, 0.7);
            margin-left: 2px;
        }

        /* Level 3+ (fourth level and beyond) */
        .nested-morphism[data-nesting-level="3"],
        .nested-morphism[data-nesting-level="4"] {
            border-left: 3px solid rgba(0, 100, 200, 0.9);
            margin-left: 2px;
        }

        .nested-samasa[data-nesting-level="3"],
        .nested-samasa[data-nesting-level="4"] {
            border-left: 3px solid rgba(150, 0, 200, 0.9);
            margin-left: 2px;
        }

        /* Cross-nested items (morphism in samasa or vice versa) */
        .nested-term .nested-term {
            margin-left: 2px;
        }

        /* Hover effect - slightly darker left border */
        .nested-morphism:hover {
            border-left-color: rgba(0, 100, 200, 0.8);
        }

        .nested-samasa:hover {
            border-left-color: rgba(150, 0, 200, 0.8);
        }

        /* Pagination */
        .pagination {
            display: flex;
            justify-content: center;
            margin: 20px 0;
        }

        .pagination button {
            background-color: #4CAF50;
            color: white;
            border: none;
            padding: 8px 16px;
            margin: 0 5px;
            cursor: pointer;
            border-radius: 4px;
        }

        .pagination button:disabled {
            background-color: #cccccc;
            cursor: not-allowed;
        }

        .pagination-info {
            margin: 0 15px;
            line-height: 32px;
        }

        /* Styling for infinite scroll */
        .term-container {
            margin-bottom: 0;
            position: relative;
            border-top: 1px solid #e0e0e0;
        }

        .term-container:first-child {
            border-top: none;
        }

        /* Highlighting for the looked-up term */
        .term-container.highlighted {
            background: linear-gradient(to right, rgba(235, 248, 255, 0.3) 0%, rgba(240, 249, 255, 0.1) 100%); /* Subtle gradient background */
            border-left: 2px solid rgba(49, 130, 206, 0.5); /* Subtle blue left border */
            margin-left: -2px; /* Offset the border to maintain alignment */
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.05); /* Very subtle shadow */
            position: relative;
            padding-top: 3px; /* Reduced padding */
            padding-bottom: 3px; /* Reduced padding */
            margin-top: 2px; /* Reduced space above */
            margin-bottom: 2px; /* Reduced space below */
            border-radius: 2px; /* Subtle rounded corners */
        }

        .term-container.highlighted .term-row {
            background: transparent; /* Make the row background transparent to show the container gradient */
        }

        .term-container.highlighted .banner {
            font-weight: 500; /* Semi-bold instead of bold */
            color: #2b6cb0; /* Brighter blue for the banner */
            text-decoration: none; /* No underline */
            font-size: 1em; /* Normal font size */
        }

        .term-container.highlighted .meaning {
            color: #2d3748; /* Slightly darker than normal text */
            font-weight: normal; /* Normal weight */
        }

        /* Specific highlighting for nested elements that match the search */
        .nested-term.search-match {
            background-color: rgba(254, 243, 199, 0.4); /* Very light yellow background */
            padding: 2px 4px;
            margin: 0 2px;
            border-radius: 2px;
        }

        .nested-term.search-match .banner,
        .nested-term.search-match .meaning {
            color: #7c2d12; /* Dark orange-brown */
            font-weight: 500; /* Semi-bold instead of bold */
        }

        .term-container::before {
            content: attr(data-term-id);
            position: absolute;
            left: -40px;
            top: 15px;
            color: #999;
            font-size: 0.9em;
        }
    </style>
</head>
<body>
    <div class="container">
        <div id="header" style="position: fixed; top: 0; left: 0; right: 0; background-color: #f5f5f5; box-shadow: 0 2px 5px rgba(0,0,0,0.1); z-index: 100;">
            <div id="file-selector" style="text-align: center; padding: 15px;">
                <div style="display: flex; justify-content: center; align-items: center;">
                    <div style="display: flex; align-items: center;">
                        <input type="text" id="devanagari-input" placeholder="Enter Devanagari Word (e.g., अंकः)" style="padding: 8px; width: 250px; margin-right: 10px;">
                        <button id="lookup-devanagari" style="background-color: #4CAF50; color: white; border: none; padding: 8px 16px; cursor: pointer; border-radius: 4px;">Lookup Word</button>
                    </div>
                </div>
            </div>
            <!-- Pagination removed as requested -->
            <div style="display: none;">
                <span id="pagination-info">Page 1</span>
                <button id="prev-page" disabled>Previous</button>
                <button id="next-page">Next</button>
            </div>
        </div>

        <!-- Spacer to push content below the fixed header -->
        <div id="header-spacer" style="height: 80px;"></div>

        <div id="loading" class="loading">Loading term data... Please wait.</div>
        <div id="error" class="error" style="display: none;"></div>

        <div id="terms-container"></div>

        <!-- Scroll loading indicators -->
        <div id="loading-top" class="scroll-loading-indicator">
            <div style="display: inline-block; margin-right: 10px; animation: spin 1s linear infinite;">⟳</div> Loading previous terms...
        </div>
        <div id="loading-bottom" class="scroll-loading-indicator">
            <div style="display: inline-block; margin-right: 10px; animation: spin 1s linear infinite;">⟳</div> Loading more terms...
        </div>

        <!-- Keyboard hint removed as requested -->
    </div>

    <script>
        // Configuration
        const PAGE_SIZE = 20;
        let currentPage = 0;
        let termsData = [];
        let pagemarks = {}; // Will store the pagemarks data
        let sortedPagemarkKeys = []; // Will store the sorted keys for binary search
        let currentTermId = null; // Current term ID being viewed
        let requestedTermId = null; // Track the term that was specifically requested
        let searchedWord = null; // Store the Devanagari word that was searched
        let isLoading = false; // Flag to prevent multiple simultaneous loads

        // Infinite scroll configuration
        const WINDOW_SIZE = 16; // Current term + 1 before + 14 after
        const WINDOW_BEFORE = 1; // 1 term before
        const WINDOW_AFTER = 14; // 14 terms after
        let loadedTerms = {}; // Map of termId -> term data
        let loadedTermIds = new Set(); // Set of loaded term IDs

        // Base URL for page links
        const PAGE_URL_BASE = "https://www.sanskrit-lexicon.uni-koeln.de/scans/csl-apidev/servepdf.php?dict=AP90&page=";

        // Function to process special text formatting
        function processSpecialText(text) {
            if (!text) return '';

            // Convert SLP1 encoded Sanskrit text in {# #} brackets to Devanagari
            text = text.replace(/\{#(.*?)#\}/g, function(match, p1) {
                try {
                    // Convert SLP1 to Devanagari
                    const devanagari = Sanscript.t(p1, 'slp1', 'devanagari');
                    return `<span class="devanagari">${devanagari}</span>`;
                } catch (e) {
                    // If conversion fails, just return the original text with special styling
                    return `<span class="special-text">${p1}</span>`;
                }
            });

            // Remove {% %} brackets but style the content differently
            text = text.replace(/\{%(.*?)%\}/g, '<span class="special-text">$1</span>');

            // Remove <ab> </ab> tags but style the content differently
            text = text.replace(/<ab>(.*?)<\/ab>/g, '<span class="special-text">$1</span>');

            return text;
        }

        // Function to process special text formatting without special styling (for banner text)
        function processPlainText(text) {
            if (!text) return '';

            // Convert SLP1 encoded Sanskrit text in {# #} brackets to Devanagari
            text = text.replace(/\{#(.*?)#\}/g, function(match, p1) {
                try {
                    // Convert SLP1 to Devanagari
                    return Sanscript.t(p1, 'slp1', 'devanagari');
                } catch (e) {
                    // If conversion fails, just return the original text
                    return p1;
                }
            });

            // Remove {% %} brackets without special styling
            text = text.replace(/\{%(.*?)%\}/g, '$1');

            // Remove <ab> </ab> tags without special styling
            text = text.replace(/<ab>(.*?)<\/ab>/g, '$1');

            return text;
        }

        // Function to process meaning text with numbered meanings
        function processMeaning(text) {
            if (!text) return '';

            // Normalize all whitespace (including newlines) to a single space
            text = text.replace(/\s+/g, ' ');

            // Handle {@--n@} format at the beginning of meanings
            text = text.replace(/\{@--(\d+)@\}/g, '<span class="meaning-number">$1</span> ');

            // Handle {n} format at the beginning of meanings
            text = text.replace(/^\{(\d+)\}\s*/g, '<span class="meaning-number">$1</span> ');

            return text;
        }

        // Function to process banner expansion
        function processBannerExp(term) {
            // If no _bannerExp, return just the _banner
            if (!term._bannerExp || !term._bannerExp.length) {
                if (term._banner) {
                    // Process special formatting but keep the text in black
                    // No warning symbol, keeping it minimal
                    return {
                        text: processPlainText(term._banner),
                        tooltip: 'No expansion available',
                        isExpanded: false,
                        matchesSearch: false
                    };
                }
                return { text: '', tooltip: '', isExpanded: false, matchesSearch: false };
            }

            // Extract all 'Right' values from _bannerExp
            const rightValues = term._bannerExp
                .filter(item => item.Right)
                .map(item => item.Right);

            // If there are Right values, use them
            if (rightValues.length > 0) {
                // Convert SLP1 to Devanagari for each Right value and check for matches
                let matchesSearch = false;
                const convertedValues = rightValues.map(value => {
                    try {
                        // Check if the value looks like Sanskrit (contains SLP1 characters)
                        // This regex checks for common SLP1 characters that indicate Sanskrit
                        if (/[AIUFXEOMNHSZR]|[kKgGNcCjJYwWqQRtTdDnpPbBmyrlvSzshL]/.test(value)) {
                            const devanagari = Sanscript.t(value, 'slp1', 'devanagari');

                            // Check if this matches the searched word
                            if (searchedWord && devanagari === searchedWord) {
                                matchesSearch = true;
                                console.log(`Found match for '${searchedWord}' in term:`, term);
                            }

                            return `<span class="devanagari">${devanagari}</span>`;
                        } else {
                            // Check if this matches the searched word (for non-Sanskrit)
                            if (searchedWord && value === searchedWord) {
                                matchesSearch = true;
                                console.log(`Found match for '${searchedWord}' in term:`, term);
                            }
                            return value; // Not Sanskrit, return as is
                        }
                    } catch (e) {
                        return value; // If conversion fails, return original
                    }
                });

                return {
                    text: convertedValues.join(', '),
                    tooltip: term._banner ? `${processPlainText(term._banner)}` : '',
                    isExpanded: true,
                    matchesSearch: matchesSearch
                };
            }

            // If all are Left values, use just the _banner
            if (term._banner) {
                // Process special formatting but keep the text in black
                // No warning symbol, keeping it minimal
                return {
                    text: processPlainText(term._banner),
                    tooltip: 'Couldn\'t expand',
                    isExpanded: false,
                    matchesSearch: false
                };
            }

            // Fallback
            return { text: '', tooltip: '', isExpanded: false, matchesSearch: false };
        }

        // Function to process a term's basic content (banner, grammar, meanings)
        function processTermContent(term) {
            let content = '';
            let matchesSearch = false;

            // Process banner/bannerExp
            const bannerInfo = processBannerExp(term);
            if (bannerInfo.text) {
                content += `<span class="banner" data-tooltip="${bannerInfo.tooltip}">${bannerInfo.text}</span>`;
                matchesSearch = bannerInfo.matchesSearch;
            }

            // Grammar info
            if (term._gram && term._gram.length) {
                content += `<span class="gram">${term._gram.map(processSpecialText).join(' ')}</span>`;
            }

            // Meanings
            if (term._meanings && term._meanings.length) {
                term._meanings.forEach(meaning => {
                    content += `<span class="meaning">${processMeaning(processSpecialText(meaning))}</span>`;
                });
            }

            return { content, matchesSearch };
        }

        // Recursive function to process morphisms at any nesting level
        function processMorphisms(morphisms, nestingLevel = 0) {
            if (!morphisms || !morphisms.length) return { html: '', hasMatch: false };

            let result = '';
            let hasMatch = false;

            morphisms.forEach(morphism => {
                const { content: morphismContent, matchesSearch } = processTermContent(morphism);
                let nestedContent = '';
                let nestedHasMatch = false;

                // Process nested morphisms recursively
                if (morphism._morphisms && morphism._morphisms.length) {
                    const nestedMorphisms = processMorphisms(morphism._morphisms, nestingLevel + 1);
                    nestedContent += nestedMorphisms.html;
                    if (nestedMorphisms.hasMatch) nestedHasMatch = true;
                }

                // Process nested samasas if any
                if (morphism._samasas && morphism._samasas.length) {
                    const nestedSamasas = processSamasas(morphism._samasas, nestingLevel + 1);
                    nestedContent += nestedSamasas.html;
                    if (nestedSamasas.hasMatch) nestedHasMatch = true;
                }

                // Add the morphism content to the result if not empty
                if (morphismContent || nestedContent) {
                    // Get ancestry info if available
                    let ancestryInfo = '';
                    if (morphism._ancestry && morphism._ancestry.length) {
                        ancestryInfo = morphism._ancestry.join(' / ');
                    }

                    // Determine if this morphism or any of its children match the search
                    const thisMatchesSearch = matchesSearch || nestedHasMatch;
                    if (thisMatchesSearch) hasMatch = true;

                    // Add appropriate classes based on search match
                    const searchMatchClass = thisMatchesSearch ? ' search-match' : '';

                    // Add nesting level as a data attribute for potential styling
                    result += `<span class="nested-term nested-morphism${searchMatchClass}" data-type="Morphism" data-nesting-level="${nestingLevel}" data-ancestry="${ancestryInfo}">${morphismContent}${nestedContent}</span>`;
                }
            });

            return { html: result, hasMatch };
        }

        // Recursive function to process samasas at any nesting level
        function processSamasas(samasas, nestingLevel = 0) {
            if (!samasas || !samasas.length) return { html: '', hasMatch: false };

            let result = '';
            let hasMatch = false;

            samasas.forEach(samasa => {
                const { content: samasaContent, matchesSearch } = processTermContent(samasa);
                let nestedContent = '';
                let nestedHasMatch = false;

                // Process nested samasas recursively
                if (samasa._samasas && samasa._samasas.length) {
                    const nestedSamasas = processSamasas(samasa._samasas, nestingLevel + 1);
                    nestedContent += nestedSamasas.html;
                    if (nestedSamasas.hasMatch) nestedHasMatch = true;
                }

                // Process nested morphisms if any
                if (samasa._morphisms && samasa._morphisms.length) {
                    const nestedMorphisms = processMorphisms(samasa._morphisms, nestingLevel + 1);
                    nestedContent += nestedMorphisms.html;
                    if (nestedMorphisms.hasMatch) nestedHasMatch = true;
                }

                // Add the samasa content to the result if not empty
                if (samasaContent || nestedContent) {
                    // Get ancestry info if available
                    let ancestryInfo = '';
                    if (samasa._ancestry && samasa._ancestry.length) {
                        ancestryInfo = samasa._ancestry.join(' / ');
                    }

                    // Determine if this samasa or any of its children match the search
                    const thisMatchesSearch = matchesSearch || nestedHasMatch;
                    if (thisMatchesSearch) hasMatch = true;

                    // Add appropriate classes based on search match
                    const searchMatchClass = thisMatchesSearch ? ' search-match' : '';

                    // Add nesting level as a data attribute for potential styling
                    result += `<span class="nested-term nested-samasa${searchMatchClass}" data-type="Samasa" data-nesting-level="${nestingLevel}" data-ancestry="${ancestryInfo}">${samasaContent}${nestedContent}</span>`;
                }
            });

            return { html: result, hasMatch };
        }

        // Function to flatten a term and all its nested terms into a single row
        function flattenTerm(term) {
            let result = '';
            let hasMatch = false;

            // Line number and page link removed

            // Process the term's own content
            const { content: termContent, matchesSearch } = processTermContent(term);
            result += termContent;
            if (matchesSearch) hasMatch = true;

            // Process morphisms with recursive handling for any nesting level
            if (term._morphisms && term._morphisms.length) {
                const morphismsResult = processMorphisms(term._morphisms);
                result += morphismsResult.html;
                if (morphismsResult.hasMatch) hasMatch = true;
            }

            // Process samasas with recursive handling for any nesting level
            if (term._samasas && term._samasas.length) {
                const samasasResult = processSamasas(term._samasas);
                result += samasasResult.html;
                if (samasasResult.hasMatch) hasMatch = true;
            }

            return { content: result, hasMatch };
        }

        // Function to render a term row
        function renderTermRow(term) {
            const { content: rowContent, hasMatch } = flattenTerm(term);
            const matchClass = hasMatch ? ' has-match' : '';
            return `<div class="term-row${matchClass}">${rowContent}</div>`;
        }

        // Function to render the current page of terms
        function renderCurrentPage() {
            const termsContainer = document.getElementById('terms-container');
            termsContainer.innerHTML = '';

            const startIndex = currentPage * PAGE_SIZE;
            const endIndex = Math.min(startIndex + PAGE_SIZE, termsData.length);

            for (let i = startIndex; i < endIndex; i++) {
                termsContainer.innerHTML += renderTermRow(termsData[i]);
            }

            // Update pagination info
            if (currentTermId) {
                document.getElementById('pagination-info').textContent = `Term ID: ${currentTermId}`;
                // Show keyboard navigation hint
                document.getElementById('keyboard-hint').style.display = 'block';
            } else {
                document.getElementById('pagination-info').textContent =
                    `Page ${currentPage + 1} of ${Math.ceil(termsData.length / PAGE_SIZE)} (${startIndex + 1}-${endIndex} of ${termsData.length})`;
                // Hide keyboard navigation hint
                document.getElementById('keyboard-hint').style.display = 'none';
            }

            // Update button states
            updateButtonStates();
        }

        // Function to update button states based on current context
        function updateButtonStates() {
            if (currentTermId) {
                // We're viewing a specific term, so prev/next navigate between terms
                document.getElementById('prev-page').disabled = currentTermId <= 1;
                document.getElementById('next-page').disabled = false; // Always allow going to next term
            } else {
                // We're viewing a regular page of terms (e.g., from es.json)
                const startIndex = currentPage * PAGE_SIZE;
                const endIndex = Math.min(startIndex + PAGE_SIZE, termsData.length);
                document.getElementById('prev-page').disabled = currentPage === 0;
                document.getElementById('next-page').disabled = endIndex >= termsData.length;
            }
        }

        // Function to load pagemarks data
        async function loadPagemarks() {
            try {
                const response = await fetch('/pagemarks-data.json');
                if (!response.ok) {
                    throw new Error(`HTTP error! Status: ${response.status}`);
                }
                const data = await response.json();
                pagemarks = data.pagemarks;
                sortedPagemarkKeys = data.sortedKeys;
                console.log(`Pagemarks loaded successfully with ${sortedPagemarkKeys.length} sorted keys`);
                return pagemarks;
            } catch (error) {
                console.error('Error loading pagemarks:', error);
                return {};
            }
        }

        // Function to get page info for a line number using binary search
        function getPageInfo(lineNumber) {
            // Convert lineNumber to a number if it's a string
            lineNumber = parseInt(lineNumber, 10);

            // If no sorted keys are available, return null
            if (!sortedPagemarkKeys || sortedPagemarkKeys.length === 0) {
                return null;
            }

            // Binary search to find the largest key less than or equal to lineNumber
            let left = 0;
            let right = sortedPagemarkKeys.length - 1;
            let result = -1;

            while (left <= right) {
                const mid = Math.floor((left + right) / 2);
                const midKey = sortedPagemarkKeys[mid];

                if (midKey <= lineNumber) {
                    // This key is a candidate, but we need to find the largest such key
                    result = mid;
                    left = mid + 1;
                } else {
                    // This key is too large
                    right = mid - 1;
                }
            }

            // If we found a valid key, extract the page number and create the URL
            if (result !== -1) {
                const maxKey = sortedPagemarkKeys[result];
                const pageMarkValue = pagemarks[maxKey];

                // Extract the page number from the format [Page????-?]...
                const match = pageMarkValue.match(/\[Page([^\]]+)\]/);
                if (match && match[1]) {
                    const pagePart = match[1].split('-')[0].trim();
                    return {
                        url: PAGE_URL_BASE + pagePart,
                        pageNumber: pagePart
                    };
                }
            }

            return null; // Return null if no valid page info could be determined
        }

        // Function to load a single term
        async function loadSingleTerm(termId) {
            try {
                // Check if term is already loaded
                if (loadedTermIds.has(termId)) {
                    return loadedTerms[termId];
                }

                const response = await fetch(`/${termId}.json`);

                if (!response.ok) {
                    // If we get a 404, it might be a gap in the term numbering
                    if (response.status === 404) {
                        console.warn(`Term ${termId} not found, treating as empty`);
                        // Create a placeholder term
                        const placeholderTerm = {
                            __placeholder: true,
                            __termId: termId,
                            _banner: `Term ${termId} not available`
                        };

                        // Store in loaded terms
                        loadedTerms[termId] = [placeholderTerm];
                        loadedTermIds.add(termId);

                        return [placeholderTerm];
                    } else {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                }

                const termData = await response.json();

                // Store in loaded terms
                loadedTerms[termId] = termData;
                loadedTermIds.add(termId);

                return termData;
            } catch (error) {
                console.error(`Error loading term ${termId}:`, error);
                return null;
            }
        }

        // Function to reset scroll and loading states
        function resetScrollStates() {
            // Reset all scroll and loading related variables
            scrollTimeout = null;
            lastBottomTermId = null;
            lastTopTermId = null;
            isLoadingTop = false;
            isLoadingBottom = false;

            // Debug mode constant (should match the one in handleScroll)
            const DEBUG_MODE = false;

            // Clear any existing debug info
            const debugEl = document.getElementById('scroll-debug');
            if (DEBUG_MODE && debugEl) {
                debugEl.innerHTML = 'Scroll states reset';
            } else if (debugEl) {
                // Remove debug element if debug mode is off
                debugEl.remove();
            }

            console.log('All scroll states have been reset');
        }

        // Function to load a term and its context (n-10 to n+10)
        async function loadTermWithContext(termId) {
            try {
                isLoading = true;

                // Reset scroll states at the beginning of loading a new term
                resetScrollStates();

                // First load pagemarks if not already loaded
                if (Object.keys(pagemarks).length === 0) {
                    await loadPagemarks();
                }

                // Set current term ID and requested term ID
                currentTermId = termId;
                requestedTermId = termId; // This is the term the user specifically requested

                // Calculate the range of terms to load
                const startTermId = Math.max(1, termId - WINDOW_BEFORE);
                const endTermId = termId + WINDOW_AFTER;

                // Show loading message
                document.getElementById('error').style.display = 'none';
                document.getElementById('loading').style.display = 'block';
                document.getElementById('loading').textContent = `Loading terms ${startTermId} to ${endTermId}...`;

                // Load all terms in the range
                const loadPromises = [];
                for (let id = startTermId; id <= endTermId; id++) {
                    loadPromises.push(loadSingleTerm(id));
                }

                await Promise.all(loadPromises);

                // Hide loading message
                document.getElementById('loading').style.display = 'none';

                // Render the terms
                renderTermsInRange(startTermId, endTermId);

                // Update pagination info
                document.getElementById('pagination-info').textContent = `Term ID: ${currentTermId}`;

                // Keyboard navigation hint has been removed

                // Update button states
                updateButtonStates();

                // Add scroll event listener if not already added
                if (!window.hasScrollListener) {
                    window.addEventListener('scroll', handleScroll);
                    window.hasScrollListener = true;
                }

                isLoading = false;
            } catch (error) {
                console.error('Error loading terms:', error);
                document.getElementById('loading').style.display = 'none';
                document.getElementById('error').style.display = 'block';
                document.getElementById('error').textContent = `Error loading terms: ${error.message}`;
                isLoading = false;
            }
        }

        // Function to render terms in a specific range
        function renderTermsInRange(startTermId, endTermId) {
            const termsContainer = document.getElementById('terms-container');
            termsContainer.innerHTML = '';

            for (let id = startTermId; id <= endTermId; id++) {
                if (loadedTermIds.has(id)) {
                    const termData = loadedTerms[id];

                    // Create a container for this term
                    const termContainer = document.createElement('div');
                    termContainer.className = 'term-container';
                    termContainer.dataset.termId = id;

                    // Add highlighting class if this is the requested term
                    if (id === requestedTermId) {
                        termContainer.classList.add('highlighted');
                    }

                    // Check if it's a placeholder
                    if (termData[0].__placeholder) {
                        termContainer.innerHTML = `<div class="term-row"><em>Term ${id} not available</em></div>`;
                    } else {
                        // Render the term
                        termContainer.innerHTML = termData.map(term => renderTermRow(term)).join('');
                    }

                    termsContainer.appendChild(termContainer);
                }
            }

            // Scroll to the most granular highlighted element after a short delay
            // to ensure all DOM updates are complete
            setTimeout(() => {
                scrollToHighlightedElement(currentTermId);
            }, 50);
        }

        // Function to load the JSON data (for backward compatibility)
        async function loadTermsData(jsonPath) {
            try {
                isLoading = true;

                // First load pagemarks
                await loadPagemarks();

                // Use the provided path or default
                const path = jsonPath || '/es.json';

                // Extract term ID from path if it's a numeric path
                const termIdMatch = path.match(/\/([0-9]+)\.json$/);
                if (termIdMatch) {
                    // If it's a term ID, use the new loading method
                    const termId = parseInt(termIdMatch[1], 10);
                    await loadTermWithContext(termId);
                    return;
                } else {
                    // For non-term paths (e.g., es.json), use the old method
                    currentTermId = null;
                }

                let response;
                try {
                    response = await fetch(path);
                } catch (e) {
                    console.error('Error fetching from path:', path, e);
                    throw new Error(`Could not fetch from ${path}: ${e.message}`);
                }

                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }

                termsData = await response.json();

                // Hide loading message
                document.getElementById('loading').style.display = 'none';

                // Render the first page
                renderCurrentPage();

                isLoading = false;
            } catch (error) {
                console.error('Error loading terms data:', error);
                document.getElementById('loading').style.display = 'none';
                document.getElementById('error').style.display = 'block';
                document.getElementById('error').textContent = `Error loading data: ${error.message}`;
                isLoading = false;
            }
        }

        // Event listeners for pagination
        document.getElementById('prev-page').addEventListener('click', () => {
            if (currentTermId) {
                // We're viewing a specific term, so go to the previous term
                if (currentTermId > 1 && !isLoading) {
                    navigateToTerm(currentTermId - 1);
                }
            } else if (currentPage > 0) {
                // Regular pagination within a page of terms
                currentPage--;
                renderCurrentPage();
                window.scrollTo(0, 0);
            }
        });

        document.getElementById('next-page').addEventListener('click', () => {
            if (currentTermId) {
                // We're viewing a specific term, so go to the next term
                if (!isLoading) {
                    navigateToTerm(currentTermId + 1);
                }
            } else if ((currentPage + 1) * PAGE_SIZE < termsData.length) {
                // Regular pagination within a page of terms
                currentPage++;
                renderCurrentPage();
                window.scrollTo(0, 0);
            }
        });

        // Function to scroll to the most granular highlighted element
        function scrollToHighlightedElement(termId) {
            // Cancel any existing scroll timeout to prevent conflicts
            if (scrollTimeout) {
                clearTimeout(scrollTimeout);
                scrollTimeout = null;
            }

            // Wait a short time to ensure the DOM is fully updated
            setTimeout(() => {
                const termElement = document.querySelector(`.term-container[data-term-id="${termId}"]`);
                if (!termElement) {
                    console.log(`Term element ${termId} not found in DOM, can't scroll`);
                    return;
                }

                // Look for a search match within this term
                const searchMatch = termElement.querySelector('.search-match');

                // Get header height to adjust calculations
                const headerHeight = document.getElementById('header').offsetHeight;

                // Reset scroll position to the top of the term first to avoid compounding errors
                // This ensures we're starting from a clean state
                termElement.scrollIntoView({ behavior: 'auto', block: 'start' });

                // Wait a tiny bit for the scroll to complete
                setTimeout(() => {
                    // Now calculate the proper center position
                    if (searchMatch) {
                        // If there's a search match, scroll to it
                        console.log('Scrolling to search match within term', termId);

                        // Get fresh coordinates after the initial scroll
                        const rect = searchMatch.getBoundingClientRect();
                        const elementHeight = rect.height;
                        const windowHeight = window.innerHeight;

                        // Calculate absolute position without using current scroll position
                        // This avoids compounding errors from previous scrolls
                        const targetScrollY = window.scrollY + rect.top - (windowHeight / 2) + (elementHeight / 2) - headerHeight;

                        console.log(`Scrolling to Y=${targetScrollY}, element top=${rect.top}, window height=${windowHeight}`);

                        // Smooth scroll to the calculated position
                        window.scrollTo({
                            top: targetScrollY,
                            behavior: 'smooth'
                        });
                    } else {
                        // Otherwise, scroll to the term itself
                        console.log('Scrolling to term', termId);

                        // Get fresh coordinates after the initial scroll
                        const rect = termElement.getBoundingClientRect();
                        const elementHeight = rect.height;
                        const windowHeight = window.innerHeight;

                        // Calculate absolute position without using current scroll position
                        // This avoids compounding errors from previous scrolls
                        const targetScrollY = window.scrollY + rect.top - (windowHeight / 2) + (elementHeight / 2) - headerHeight;

                        console.log(`Scrolling to Y=${targetScrollY}, element top=${rect.top}, window height=${windowHeight}`);

                        // Smooth scroll to the calculated position
                        window.scrollTo({
                            top: targetScrollY,
                            behavior: 'smooth'
                        });
                    }
                }, 50); // Short delay to ensure the initial scroll is complete
            }, 100); // Wait for DOM updates to complete
        }

        // Function to navigate to a specific term
        function navigateToTerm(termId) {
            if (isLoading) return;

            // Parse termId as integer
            termId = parseInt(termId, 10);
            if (isNaN(termId) || termId <= 0) {
                alert('Please enter a valid Term ID');
                return;
            }

            // Reset scroll states to prevent incorrect scrolling
            resetScrollStates();

            // Force scroll to top to reset view
            window.scrollTo(0, 0);

            // Clear any previous errors
            document.getElementById('error').style.display = 'none';
            document.getElementById('loading').style.display = 'block';
            document.getElementById('loading').textContent = `Loading Term ID: ${termId}...`;

            // Update URL without reloading the page
            const newUrl = new URL(window.location.href);
            newUrl.searchParams.set('path', `/${termId}.json`);
            window.history.pushState({}, '', newUrl.toString());

            // Load the term and its context
            loadTermWithContext(termId);
        }

        // No file input handling needed

        // Default path for the JSON file
        const DEFAULT_JSON_PATH = '/es.json'; // When using the server, this will be served from apteDir.nosync/output/es.json

        // Function to get URL parameters
        function getUrlParameter(name) {
            name = name.replace(/[\[]/, '\\[').replace(/[\]]/, '\\]');
            const regex = new RegExp('[\\?&]' + name + '=([^&#]*)');
            const results = regex.exec(location.search);
            return results === null ? '' : decodeURIComponent(results[1].replace(/\+/g, ' '));
        }

        // No default path button anymore

        // Function to lookup a Devanagari word in table2.txt
        async function lookupDevanagariWord(word) {
            if (isLoading) return;

            if (!word) {
                alert('Please enter a Devanagari word');
                return;
            }

            // Reset scroll states to prevent incorrect scrolling
            resetScrollStates();

            // Force scroll to top to reset view
            window.scrollTo(0, 0);

            // Store the searched word for highlighting nested elements
            searchedWord = word.trim();

            // Show loading message
            document.getElementById('error').style.display = 'none';
            document.getElementById('loading').style.display = 'block';
            document.getElementById('loading').textContent = `Looking up word: ${word}...`;

            try {
                // Fetch table2.txt
                const response = await fetch('/table2.txt');
                if (!response.ok) {
                    throw new Error(`Failed to load table2.txt: ${response.status} ${response.statusText}`);
                }

                const text = await response.text();
                const lines = text.split('\n');

                // Search for the word
                let termId = null;
                for (const line of lines) {
                    const parts = line.split(' : ');
                    if (parts.length >= 2 && parts[0].trim() === word.trim()) {
                        // Found a match, extract the L_ number
                        const match = parts[1].match(/L_\s*(\d+)/);
                        if (match && match[1]) {
                            termId = parseInt(match[1], 10);
                            break;
                        }
                    }
                }

                if (termId) {
                    // Navigate to the term
                    navigateToTerm(termId);
                } else {
                    // Word not found
                    document.getElementById('loading').style.display = 'none';
                    document.getElementById('error').style.display = 'block';
                    document.getElementById('error').textContent = `Word "${word}" not found in dictionary.`;
                }
            } catch (error) {
                console.error('Error looking up word:', error);
                document.getElementById('loading').style.display = 'none';
                document.getElementById('error').style.display = 'block';
                document.getElementById('error').textContent = `Error looking up word: ${error.message}`;
            }
        }

        // Term ID input feature has been removed

        // Event listener for the lookup Devanagari word button
        document.getElementById('lookup-devanagari').addEventListener('click', function() {
            const word = document.getElementById('devanagari-input').value.trim();
            lookupDevanagariWord(word);
        });

        // Handle Enter key in the Devanagari input field
        document.getElementById('devanagari-input').addEventListener('keypress', function(event) {
            if (event.key === 'Enter') {
                event.preventDefault();
                document.getElementById('lookup-devanagari').click();
            }
        });

        // Keyboard navigation has been removed as requested

        // Scroll event handler for infinite scrolling
        let scrollTimeout;
        let lastBottomTermId = null;
        let lastTopTermId = null;
        const BATCH_SIZE = 7; // Load half the WINDOW_AFTER size at once
        const SCROLL_TIMEOUT = 300; // Increased timeout for larger payloads
        let isLoadingTop = false; // Flag to track loading state for top indicator
        let isLoadingBottom = false; // Flag to track loading state for bottom indicator

        function handleScroll() {
            // Debug element code is kept but disabled
            // To re-enable, set DEBUG_MODE to true
            const DEBUG_MODE = false;

            let debugEl = document.getElementById('scroll-debug');
            if (DEBUG_MODE) {
                if (!debugEl) {
                    debugEl = document.createElement('div');
                    debugEl.id = 'scroll-debug';
                    debugEl.style.position = 'fixed';
                    debugEl.style.bottom = '10px';
                    debugEl.style.right = '10px';
                    debugEl.style.backgroundColor = 'rgba(0,0,0,0.7)';
                    debugEl.style.color = 'white';
                    debugEl.style.padding = '10px';
                    debugEl.style.borderRadius = '5px';
                    debugEl.style.zIndex = '1000';
                    debugEl.style.fontSize = '12px';
                    document.body.appendChild(debugEl);
                }
            } else if (debugEl) {
                // Remove debug element if it exists and debug mode is off
                debugEl.remove();
                debugEl = null;
            }

            if (scrollTimeout || isLoading || !currentTermId) {
                if (DEBUG_MODE && debugEl) {
                    debugEl.innerHTML = `Waiting: timeout=${!!scrollTimeout}, loading=${isLoading}, currentTermId=${currentTermId}`;
                }
                return;
            }

            // Get viewport dimensions
            const scrollPosition = window.scrollY;
            const windowHeight = window.innerHeight;
            const documentHeight = document.documentElement.scrollHeight;
            const headerHeight = document.getElementById('header').offsetHeight;

            // Adjust scroll position to account for fixed header
            const effectiveScrollPosition = scrollPosition + headerHeight;

            // Get all loaded term IDs in order
            const termContainers = document.querySelectorAll('.term-container');
            const loadedIds = Array.from(termContainers).map(container =>
                parseInt(container.dataset.termId, 10)).sort((a, b) => a - b);

            // Find the highest and lowest loaded term IDs
            const lowestLoadedId = loadedIds.length > 0 ? loadedIds[0] : currentTermId;
            const highestLoadedId = loadedIds.length > 0 ? loadedIds[loadedIds.length - 1] : currentTermId;

            // Update debug display if debug mode is enabled
            if (DEBUG_MODE && debugEl) {
                debugEl.innerHTML = `Scroll: ${scrollPosition}px<br>
                    Effective Scroll: ${effectiveScrollPosition}px<br>
                    Window Height: ${windowHeight}px<br>
                    Document Height: ${documentHeight}px<br>
                    Header Height: ${headerHeight}px<br>
                    Lowest ID: ${lowestLoadedId}<br>
                    Highest ID: ${highestLoadedId}<br>
                    Current ID: ${currentTermId}<br>
                    Near Top: ${scrollPosition < 200}<br>
                    Near Bottom: ${scrollPosition + windowHeight > documentHeight - 500}`;
            }

            scrollTimeout = setTimeout(() => {
                // Check if we're near the bottom of the page
                // Use a larger threshold for bottom detection to ensure it triggers properly
                const nearBottom = scrollPosition + windowHeight > documentHeight - 500;

                // Check if we're near the top of the content (accounting for fixed header)
                const nearTop = scrollPosition < 200;

                // Near the bottom of the page - load more terms below
                if (nearBottom) {
                    const nextTermId = highestLoadedId + 1;

                    // Check if the next term is actually in the DOM
                    const nextTermInDOM = document.querySelector(`.term-container[data-term-id="${nextTermId}"]`);

                    // Only load if we haven't loaded this term before or if it's different from the last one we tried to load
                    // Also check if the term is actually in the DOM, not just in the loadedTermIds set
                    if ((nextTermId !== lastBottomTermId) && (!loadedTermIds.has(nextTermId) || !nextTermInDOM) && nextTermId > 0) {
                        // Show loading indicator at the bottom
                        document.getElementById('loading-bottom').style.display = 'block';
                        isLoadingBottom = true;

                        // If the term is in loadedTermIds but not in DOM, remove it from loadedTermIds
                        if (loadedTermIds.has(nextTermId) && !nextTermInDOM) {
                            loadedTermIds.delete(nextTermId);
                            console.log(`Term ${nextTermId} was in loadedTermIds but not in DOM, removed from tracking`);
                        }

                        // Load a batch of terms instead of just one
                        const batchEndId = nextTermId + BATCH_SIZE - 1;
                        console.log(`Loading more terms below: ${nextTermId} to ${batchEndId}`);
                        if (DEBUG_MODE && debugEl) {
                            debugEl.innerHTML += `<br><strong>Loading below: ${nextTermId} to ${batchEndId}</strong>`;
                        }
                        lastBottomTermId = nextTermId;

                        // Load each term in the batch
                        const loadPromises = [];
                        for (let id = nextTermId; id <= batchEndId; id++) {
                            loadPromises.push(loadMoreTerms(id, 'below'));
                        }

                        // Hide loading indicator when all terms are loaded
                        Promise.all(loadPromises).finally(() => {
                            setTimeout(() => {
                                document.getElementById('loading-bottom').style.display = 'none';
                                isLoadingBottom = false;
                                lastBottomTermId = null; // Reset to allow loading more if needed
                            }, 300); // Short delay to ensure user sees the indicator
                        });
                    } else {
                        if (DEBUG_MODE && debugEl) {
                            debugEl.innerHTML += `<br>Not loading below: nextTermId=${nextTermId}, lastBottomTermId=${lastBottomTermId}, already loaded=${loadedTermIds.has(nextTermId)}, in DOM=${!!nextTermInDOM}`;
                        }

                        // If we're at the bottom but can't load more, reset lastBottomTermId after a delay
                        // This helps recover from stuck states
                        if (lastBottomTermId !== null) {
                            setTimeout(() => {
                                lastBottomTermId = null;
                                console.log('Reset lastBottomTermId to allow loading more terms');
                            }, 2000); // Wait 2 seconds before allowing another attempt
                        }
                    }
                }

                // Near the top of the page - load more terms above
                if (nearTop && lowestLoadedId > 1) {
                    const prevTermId = lowestLoadedId - 1;

                    // Check if the previous term is actually in the DOM
                    const prevTermInDOM = document.querySelector(`.term-container[data-term-id="${prevTermId}"]`);

                    // Only load if we haven't loaded this term before or if it's different from the last one we tried to load
                    // Also check if the term is actually in the DOM, not just in the loadedTermIds set
                    if ((prevTermId !== lastTopTermId) && (!loadedTermIds.has(prevTermId) || !prevTermInDOM) && prevTermId >= 1) {
                        // Show loading indicator at the top
                        document.getElementById('loading-top').style.display = 'block';
                        isLoadingTop = true;

                        // If the term is in loadedTermIds but not in DOM, remove it from loadedTermIds
                        if (loadedTermIds.has(prevTermId) && !prevTermInDOM) {
                            loadedTermIds.delete(prevTermId);
                            console.log(`Term ${prevTermId} was in loadedTermIds but not in DOM, removed from tracking`);
                        }

                        // Load a batch of terms instead of just one
                        const batchStartId = Math.max(1, prevTermId - BATCH_SIZE + 1);
                        console.log(`Loading more terms above: ${batchStartId} to ${prevTermId}`);
                        if (DEBUG_MODE && debugEl) {
                            debugEl.innerHTML += `<br><strong>Loading above: ${batchStartId} to ${prevTermId}</strong>`;
                        }
                        lastTopTermId = prevTermId;

                        // Load each term in the batch
                        const loadPromises = [];
                        for (let id = prevTermId; id >= batchStartId; id--) {
                            loadPromises.push(loadMoreTerms(id, 'above'));
                        }

                        // Hide loading indicator when all terms are loaded
                        Promise.all(loadPromises).finally(() => {
                            setTimeout(() => {
                                document.getElementById('loading-top').style.display = 'none';
                                isLoadingTop = false;
                                lastTopTermId = null; // Reset to allow loading more if needed
                            }, 300); // Short delay to ensure user sees the indicator
                        });
                    } else {
                        if (DEBUG_MODE && debugEl) {
                            debugEl.innerHTML += `<br>Not loading above: prevTermId=${prevTermId}, lastTopTermId=${lastTopTermId}, already loaded=${loadedTermIds.has(prevTermId)}, in DOM=${!!prevTermInDOM}`;
                        }

                        // If we're at the top but can't load more, reset lastTopTermId after a delay
                        // This helps recover from stuck states
                        if (lastTopTermId !== null) {
                            setTimeout(() => {
                                lastTopTermId = null;
                                console.log('Reset lastTopTermId to allow loading more terms');
                            }, 2000); // Wait 2 seconds before allowing another attempt
                        }
                    }
                }

                // Update current term ID based on scroll position
                updateCurrentTermIdFromScroll();

                scrollTimeout = null;

                // Add a recovery mechanism for when scrolling gets stuck
                // If we're near the top or bottom but couldn't load more terms, check if we have enough terms in the DOM
                const visibleTerms = document.querySelectorAll('.term-container').length;
                if ((nearTop || nearBottom) && visibleTerms < WINDOW_SIZE) {
                    console.log(`Possible stuck state detected: only ${visibleTerms} terms visible. Attempting recovery...`);
                    if (DEBUG_MODE && debugEl) {
                        debugEl.innerHTML += `<br><strong>Recovery: Only ${visibleTerms} terms visible, forcing reload</strong>`;
                    }

                    // Force reset tracking variables
                    lastTopTermId = null;
                    lastBottomTermId = null;

                    // Force reload around current term
                    const recoveryStart = Math.max(1, currentTermId - WINDOW_BEFORE);
                    const recoveryEnd = currentTermId + WINDOW_AFTER;

                    // Clear loadedTermIds for terms that should be visible but aren't in the DOM
                    for (let id = recoveryStart; id <= recoveryEnd; id++) {
                        if (loadedTermIds.has(id) && !document.querySelector(`.term-container[data-term-id="${id}"]`)) {
                            loadedTermIds.delete(id);
                            console.log(`Recovery: Removed term ${id} from tracking as it's not in the DOM`);
                        }
                    }

                    // Force reload the current window of terms
                    setTimeout(() => {
                        renderTermsInRange(recoveryStart, recoveryEnd);
                    }, 500);
                }
            }, SCROLL_TIMEOUT);
        }

        // Function to load more terms in a specific direction
        async function loadMoreTerms(termId, direction) {
            if (isLoading || !termId || termId < 1) return Promise.resolve();

            // Check if this term is already loaded
            if (document.querySelector(`.term-container[data-term-id="${termId}"]`)) {
                console.log(`Term ${termId} is already in the DOM, skipping`);
                return Promise.resolve();
            }

            try {
                isLoading = true;

                // Load the term
                const termData = await loadSingleTerm(termId);

                if (termData) {
                    // Double-check that the term hasn't been added while we were loading
                    if (document.querySelector(`.term-container[data-term-id="${termId}"]`)) {
                        console.log(`Term ${termId} was added while loading, skipping`);
                        isLoading = false;
                        return;
                    }

                    // Get the terms container
                    const termsContainer = document.getElementById('terms-container');

                    // Create a container for this term
                    const termContainer = document.createElement('div');
                    termContainer.className = 'term-container';
                    termContainer.dataset.termId = termId;

                    // Add highlighting class if this is the requested term
                    if (termId === requestedTermId) {
                        termContainer.classList.add('highlighted');
                    }

                    // Check if it's a placeholder
                    if (termData[0].__placeholder) {
                        termContainer.innerHTML = `<div class="term-row"><em>Term ${termId} not available</em></div>`;
                    } else {
                        // Render the term
                        termContainer.innerHTML = termData.map(term => renderTermRow(term)).join('');
                    }

                    // Add to the DOM in the appropriate position
                    if (direction === 'above') {
                        // Save current scroll position and document height
                        const oldScrollY = window.scrollY;
                        const oldDocumentHeight = document.documentElement.scrollHeight;

                        // Add the new term at the top
                        termsContainer.insertBefore(termContainer, termsContainer.firstChild);
                        console.log(`Added term ${termId} at the top`);

                        // Wait for the DOM to update
                        setTimeout(() => {
                            // Calculate how much the document height changed
                            const newDocumentHeight = document.documentElement.scrollHeight;
                            const heightDifference = newDocumentHeight - oldDocumentHeight;

                            // Adjust scroll position to maintain the same view
                            if (heightDifference > 0) {
                                window.scrollTo(0, oldScrollY + heightDifference);
                                console.log(`Adjusted scroll position by ${heightDifference}px (from ${oldScrollY} to ${oldScrollY + heightDifference})`);
                            }
                        }, 0);
                    } else {
                        termsContainer.appendChild(termContainer);
                        console.log(`Added term ${termId} at the bottom`);
                    }

                    // Trim excess terms to maintain the window size
                    trimExcessTerms();
                }

                isLoading = false;
                return Promise.resolve();
            } catch (error) {
                console.error(`Error loading more terms:`, error);
                isLoading = false;
                return Promise.reject(error);
            }
        }

        // Function to trim excess terms to maintain the window size
        function trimExcessTerms() {
            const termContainers = document.querySelectorAll('.term-container');
            if (termContainers.length <= WINDOW_SIZE * 4) return; // Keep a larger buffer (4x instead of 2x)

            // Get the current term element
            const currentTermElement = document.querySelector(`.term-container[data-term-id="${currentTermId}"]`);
            if (!currentTermElement) return;

            // Calculate which terms to keep
            const termIds = Array.from(termContainers).map(container => parseInt(container.dataset.termId, 10));
            const minKeepId = Math.max(1, currentTermId - WINDOW_BEFORE);
            const maxKeepId = currentTermId + WINDOW_AFTER;

            // Remove terms that are too far from the current term
            for (const container of termContainers) {
                const termId = parseInt(container.dataset.termId, 10);
                if (termId < minKeepId || termId > maxKeepId) {
                    // Remove from DOM
                    container.remove();

                    // Also remove from loadedTermIds set to allow reloading if needed
                    loadedTermIds.delete(termId);

                    // Reset lastTopTermId and lastBottomTermId if they match the removed term
                    if (termId === lastTopTermId) {
                        lastTopTermId = null;
                    }
                    if (termId === lastBottomTermId) {
                        lastBottomTermId = null;
                    }

                    console.log(`Removed term ${termId} from DOM and tracking`);
                }
            }
        }

        // Function to update current term ID based on scroll position
        function updateCurrentTermIdFromScroll() {
            const termContainers = document.querySelectorAll('.term-container');
            if (!termContainers.length) return;

            // Get header height to adjust calculations
            const headerHeight = document.getElementById('header').offsetHeight;

            // Find the term closest to the center of the viewport (adjusted for header)
            const viewportMiddle = (window.innerHeight - headerHeight) / 2 + headerHeight;
            let closestTerm = null;
            let closestDistance = Infinity;

            for (const container of termContainers) {
                const rect = container.getBoundingClientRect();
                const termMiddle = rect.top + rect.height / 2;
                const distance = Math.abs(termMiddle - viewportMiddle);

                if (distance < closestDistance) {
                    closestDistance = distance;
                    closestTerm = container;
                }
            }

            if (closestTerm) {
                const newTermId = parseInt(closestTerm.dataset.termId, 10);

                // Only update if it changed
                if (newTermId !== currentTermId) {
                    // Update current term ID
                    currentTermId = newTermId;

                    // Update URL without reloading the page
                    const newUrl = new URL(window.location.href);
                    newUrl.searchParams.set('path', `/${currentTermId}.json`);
                    window.history.pushState({}, '', newUrl.toString());

                    // Update pagination info
                    document.getElementById('pagination-info').textContent = `Term ID: ${currentTermId}`;

                    // Update button states
                    updateButtonStates();
                }
            }
        }

        // Load data only if path parameter is provided in URL
        document.addEventListener('DOMContentLoaded', function() {
            // Make sure loading indicators are hidden initially
            document.getElementById('loading-top').style.display = 'none';
            document.getElementById('loading-bottom').style.display = 'none';

            // Check if path is provided in URL
            const jsonPath = getUrlParameter('path');
            if (jsonPath) {
                loadTermsData(jsonPath);
            } else {
                // Hide loading message if no path is provided
                document.getElementById('loading').style.display = 'none';
            }
        });
    </script>
</body>
</html>
